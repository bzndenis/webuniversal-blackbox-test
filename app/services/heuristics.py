"""Form detection and automated testing heuristics."""

from playwright.sync_api import Page, Locator
from typing import Dict, Any, List, Optional
import logging
import os

logger = logging.getLogger(__name__)


def detect_forms(page: Page) -> List[Dict[str, Any]]:
    """
    Detect all forms on the page.
    
    Args:
        page: Playwright page object
        
    Returns:
        List of form information dictionaries
    """
    forms = []
    form_elements = page.locator('form')
    
    for i in range(form_elements.count()):
        form = form_elements.nth(i)
        
        form_info = {
            'index': i,
            'action': form.get_attribute('action') or '',
            'method': form.get_attribute('method') or 'GET',
            'inputs': []
        }
        
        # Find all inputs in this form
        inputs = form.locator('input, textarea, select')
        for j in range(inputs.count()):
            input_elem = inputs.nth(j)
            input_type = input_elem.get_attribute('type') or 'text'
            
            # Skip buttons and submits for now
            if input_type in ['submit', 'button', 'image', 'reset']:
                continue
            
            input_info = {
                'type': input_type,
                'name': input_elem.get_attribute('name') or '',
                'id': input_elem.get_attribute('id') or '',
                'required': input_elem.get_attribute('required') is not None,
                'placeholder': input_elem.get_attribute('placeholder') or ''
            }
            form_info['inputs'].append(input_info)
        
        forms.append(form_info)
    
    return forms


def generate_dummy_data(input_type: str, name: str = '', placeholder: str = '') -> str:
    """
    Generate dummy data based on input type and context.
    
    Args:
        input_type: HTML input type
        name: Input name attribute
        placeholder: Input placeholder text
        
    Returns:
        Dummy value string
    """
    name_lower = name.lower()
    placeholder_lower = placeholder.lower()
    
    # Email detection
    if input_type == 'email' or 'email' in name_lower or 'email' in placeholder_lower:
        return 'test@example.com'
    
    # Password detection
    if input_type == 'password' or 'password' in name_lower or 'pass' in name_lower:
        return 'Test123!@#'
    
    # Phone detection
    if input_type == 'tel' or 'phone' in name_lower or 'tel' in name_lower:
        return '+1234567890'
    
    # Number detection
    if input_type == 'number':
        return '42'
    
    # Date detection
    if input_type == 'date':
        return '2024-01-15'
    
    # Time detection
    if input_type == 'time':
        return '14:30'
    
    # URL detection
    if input_type == 'url' or 'url' in name_lower or 'website' in name_lower:
        return 'https://example.com'
    
    # Name detection
    if 'name' in name_lower or 'nama' in name_lower:
        if 'first' in name_lower or 'depan' in name_lower:
            return 'John'
        elif 'last' in name_lower or 'belakang' in name_lower:
            return 'Doe'
        else:
            return 'John Doe'
    
    # Address detection
    if 'address' in name_lower or 'alamat' in name_lower:
        return '123 Main Street, City, State 12345'
    
    # Textarea or message
    if input_type == 'textarea' or 'message' in name_lower or 'comment' in name_lower:
        return 'This is a test message generated by automated testing.'
    
    # Default text
    return 'Test Input'


def fill_form(
    page: Page,
    form_index: int = 0,
    submit: bool = False
) -> Dict[str, Any]:
    """
    Automatically fill a form with dummy data.
    
    Args:
        page: Playwright page object
        form_index: Index of form to fill (default: 0)
        submit: Whether to submit the form (default: False)
        
    Returns:
        Dictionary with fill results
    """
    result = {
        'form_index': form_index,
        'fields_filled': 0,
        'fields_failed': 0,
        'submitted': False,
        'errors': []
    }
    
    try:
        # Enhanced form detection with better debugging
        forms = page.locator('form')
        form_count = forms.count()
        logger.info(f"Found {form_count} forms on page")
        
        if form_count == 0:
            logger.warning("No forms found, trying alternative selectors...")
            
            # Try alternative form selectors
            alt_form_selectors = [
                'form',
                '[role="form"]',
                '.form',
                '#form',
                'div[class*="form"]',
                'section[class*="form"]'
            ]
            
            for selector in alt_form_selectors:
                alt_forms = page.locator(selector)
                count = alt_forms.count()
                if count > 0:
                    logger.info(f"Found {count} elements with selector '{selector}'")
                    forms = alt_forms
                    form_count = count
                    break
        
        if form_count == 0:
            result['errors'].append("No forms found on page")
            logger.error("No forms found with any selector")
            return result
        
        if form_count <= form_index:
            result['errors'].append(f"Form index {form_index} not found (only {form_count} forms available)")
            logger.error(f"Form index {form_index} not found (only {form_count} forms available)")
            return result
        
        form = forms.nth(form_index)
        logger.info(f"Using form {form_index} with {form_count} total forms available")
        
        # Fill text inputs - expanded selectors for modern frameworks
        text_input_selectors = [
            'input[type="text"]',
            'input[type="email"]', 
            'input[type="tel"]',
            'input[type="url"]',
            'input[type="search"]',
            'input:not([type])',
            'input[type="number"]',
            'input[type="date"]',
            'input[type="time"]',
            'input[type="datetime-local"]',
            'input[type="month"]',
            'input[type="week"]',
            'input[type="color"]',
            'input[type="range"]',
            'input[type="file"]',
            'input[type="checkbox"]',
            'input[type="radio"]',
            'input[type="hidden"]',
            'input',  # Catch all inputs
            'textarea',
            'select'
        ]
        
        # Try each selector individually for better debugging
        total_inputs = 0
        for selector in text_input_selectors:
            try:
                inputs = form.locator(selector)
                count = inputs.count()
                if count > 0:
                    logger.info(f"Found {count} elements with selector '{selector}'")
                    total_inputs += count
            except Exception as e:
                logger.debug(f"Error with selector '{selector}': {e}")
        
        logger.info(f"Total inputs found: {total_inputs}")
        
        # Use comprehensive selector with better debugging
        text_inputs = form.locator('input, textarea, select')
        logger.info(f"Found {text_inputs.count()} total inputs in form {form_index}")
        
        # Additional debugging - check if form is actually found
        if text_inputs.count() == 0:
            logger.warning(f"No inputs found in form {form_index}, trying alternative selectors...")
            
            # Try alternative selectors
            alt_selectors = [
                'input:not([type="hidden"])',
                'input[type="text"], input[type="email"], input[type="password"], input[type="number"], input[type="date"], input[type="time"]',
                'textarea',
                'select'
            ]
            
            for alt_selector in alt_selectors:
                alt_inputs = form.locator(alt_selector)
                count = alt_inputs.count()
                if count > 0:
                    logger.info(f"Found {count} inputs with alternative selector: {alt_selector}")
                    text_inputs = alt_inputs
                    break
        
        for i in range(text_inputs.count()):
            try:
                input_elem = text_inputs.nth(i)
                name = input_elem.get_attribute('name') or ''
                input_type = input_elem.get_attribute('type') or 'text'
                placeholder = input_elem.get_attribute('placeholder') or ''
                
                # Get tag name safely
                try:
                    tag_name = input_elem.evaluate('el => el.tagName').lower()
                except Exception:
                    tag_name = 'unknown'
                
                logger.info(f"Processing input {i}: tag={tag_name}, type={input_type}, name={name}")
                
                # Skip hidden inputs
                if input_type == 'hidden':
                    logger.debug(f"Skipping hidden input: {name}")
                    continue
                
                # Check if input is visible and enabled with better error handling
                try:
                    is_visible = input_elem.is_visible()
                    is_disabled = input_elem.is_disabled()
                    logger.info(f"Input {i}: visible={is_visible}, disabled={is_disabled}")
                    
                    if not is_visible:
                        logger.info(f"Skipping invisible input: {name}")
                        continue
                        
                    if is_disabled:
                        logger.info(f"Skipping disabled input: {name}")
                        continue
                        
                except Exception as e:
                    logger.warning(f"Could not check visibility/disabled for input {i}: {e}")
                    # Continue anyway, might be a framework issue
                    logger.info(f"Attempting to fill input {i} anyway...")
                
                # Handle different input types
                if tag_name == 'select':
                    # Handle select elements
                    options = input_elem.locator('option')
                    if options.count() > 1:
                        input_elem.select_option(index=1)
                        result['fields_filled'] += 1
                        logger.info(f"Selected option in select '{name}'")
                elif input_type in ['checkbox', 'radio']:
                    # Handle checkboxes and radio buttons
                    if not input_elem.is_checked():
                        input_elem.check()
                        result['fields_filled'] += 1
                        logger.info(f"Checked {input_type} '{name}'")
                elif input_type == 'file':
                    # Skip file inputs for now
                    logger.debug(f"Skipping file input: {name}")
                    continue
                else:
                    # Handle text inputs
                    value = generate_dummy_data(input_type, name, placeholder)
                    input_elem.fill(value)
                    result['fields_filled'] += 1
                    logger.info(f"Filled input '{name}' (type: {input_type}) with '{value}'")
                    
            except Exception as e:
                result['fields_failed'] += 1
                result['errors'].append(f"Failed to fill input {i}: {str(e)}")
                logger.error(f"Failed to fill input {i}: {e}")
        
        # All input types are now handled in the main loop above
        
        # Submit if requested
        if submit:
            try:
                # Look for submit button with more selectors
                submit_selectors = [
                    'button[type="submit"]',
                    'input[type="submit"]',
                    'button:has-text("Submit")',
                    'button:has-text("Submit order")',
                    'button:has-text("Send")',
                    'button:has-text("Post")',
                    'button:has-text("Save")',
                    'button:has-text("Send Message")',
                    'button:has-text("Submit Form")',
                    'button:not([type])',  # Button without type (defaults to submit)
                    'input[type="button"]:has-text("Submit")',
                    'button'  # Any button in form (fallback)
                ]
                
                submit_button = None
                for selector in submit_selectors:
                    try:
                        btn = form.locator(selector).first
                        if btn.count() > 0 and btn.is_visible() and not btn.is_disabled():
                            submit_button = btn
                            logger.info(f"Found submit button with selector: {selector}")
                            break
                    except Exception:
                        continue
                
                if submit_button:
                    submit_button.click()
                    result['submitted'] = True
                    logger.info("Form submitted via submit button")
                    page.wait_for_timeout(1000)  # Wait for submission
                else:
                    # Try to submit via form
                    form.evaluate('form => form.submit()')
                    result['submitted'] = True
                    logger.info("Form submitted via form.submit()")
            except Exception as e:
                result['errors'].append(f"Failed to submit form: {str(e)}")
                logger.error(f"Failed to submit form: {e}")
        
        logger.info(f"Form filling completed: {result['fields_filled']} filled, {result['fields_failed']} failed")
        
        # If no fields were filled, try a more aggressive approach
        if result['fields_filled'] == 0:
            logger.warning("No fields were filled with standard approach, trying aggressive detection...")
            
            # Try to find any input on the page, not just in form
            page_inputs = page.locator('input:not([type="hidden"]), textarea, select')
            logger.info(f"Found {page_inputs.count()} inputs on entire page")
            
            # Also try to find form-like containers
            form_containers = page.locator('div[class*="form"], section[class*="form"], div[class*="field"], div[class*="input"]')
            logger.info(f"Found {form_containers.count()} form-like containers")
            
            for i in range(min(page_inputs.count(), 20)):  # Increased limit
                try:
                    input_elem = page_inputs.nth(i)
                    name = input_elem.get_attribute('name') or f'input_{i}'
                    input_type = input_elem.get_attribute('type') or 'text'
                    placeholder = input_elem.get_attribute('placeholder') or ''
                    
                    # Check if it's visible and not disabled
                    if input_elem.is_visible() and not input_elem.is_disabled():
                        try:
                            if input_type in ['checkbox', 'radio']:
                                if not input_elem.is_checked():
                                    input_elem.check()
                                    result['fields_filled'] += 1
                                    logger.info(f"Aggressively filled {input_type} '{name}'")
                            elif input_type == 'file':
                                # Skip file inputs for now
                                logger.debug(f"Skipping file input: {name}")
                                continue
                            else:
                                value = generate_dummy_data(input_type, name, placeholder)
                                input_elem.fill(value)
                                result['fields_filled'] += 1
                                logger.info(f"Aggressively filled input '{name}' with '{value}'")
                        except Exception as e:
                            logger.debug(f"Could not fill input {i} aggressively: {e}")
                except Exception as e:
                    logger.debug(f"Error in aggressive filling for input {i}: {e}")
            
            logger.info(f"Aggressive filling completed: {result['fields_filled']} filled")
    
    except Exception as e:
        result['errors'].append(f"Form filling error: {str(e)}")
        logger.error(f"Form filling error: {e}")
    
    return result


def save_session_state(page: Page) -> Dict[str, Any]:
    """
    Simpan state session untuk persistence.
    
    Args:
        page: Playwright page object
        
    Returns:
        Dictionary berisi session state
    """
    try:
        session_state = {
            'cookies': page.context.cookies(),
            'local_storage': page.evaluate('() => Object.fromEntries(Object.entries(localStorage))'),
            'session_storage': page.evaluate('() => Object.fromEntries(Object.entries(sessionStorage))'),
            'url': page.url
        }
        logger.info(f"Session state saved: {len(session_state['cookies'])} cookies")
        return session_state
    except Exception as e:
        logger.warning(f"Failed to save session state: {e}")
        return {}


def restore_session_state(page: Page, session_state: Dict[str, Any]) -> bool:
    """
    Pulihkan state session dari yang tersimpan.
    
    Args:
        page: Playwright page object
        session_state: Dictionary berisi session state
        
    Returns:
        True jika berhasil, False jika gagal
    """
    try:
        if 'cookies' in session_state:
            page.context.add_cookies(session_state['cookies'])
            logger.info(f"Session cookies restored: {len(session_state['cookies'])} cookies")
        
        if 'local_storage' in session_state:
            for key, value in session_state['local_storage'].items():
                page.evaluate(f'localStorage.setItem("{key}", "{value}")')
            logger.info(f"Local storage restored: {len(session_state['local_storage'])} items")
        
        if 'session_storage' in session_state:
            for key, value in session_state['session_storage'].items():
                page.evaluate(f'sessionStorage.setItem("{key}", "{value}")')
            logger.info(f"Session storage restored: {len(session_state['session_storage'])} items")
        
        return True
    except Exception as e:
        logger.warning(f"Failed to restore session state: {e}")
        return False


def check_session_validity(page: Page) -> bool:
    """
    Periksa apakah session masih valid dengan mengecek indikator login.
    
    Args:
        page: Playwright page object
        
    Returns:
        True jika session masih valid, False jika perlu login ulang
    """
    try:
        current_url = page.url.lower()
        
        # Cek URL untuk indikator login
        login_url_indicators = [
            '/login', '/signin', '/auth', '/masuk', '/admin/login',
            'login', 'signin', 'authentication'
        ]
        
        if any(indicator in current_url for indicator in login_url_indicators):
            logger.warning(f"Session invalid - current URL indicates login page: {current_url}")
            return False
        
        # Cek apakah ada indikator yang menunjukkan user sudah login
        login_indicators = [
            'a[href*="logout"]',
            'button:has-text("Logout")',
            'a:has-text("Logout")',
            '.user-menu',
            '.profile-menu',
            '[class*="user"]',
            '[class*="profile"]',
            '.admin-menu',
            '.dashboard-menu'
        ]
        
        for indicator in login_indicators:
            if page.locator(indicator).count() > 0:
                logger.info(f"Session valid - found login indicator: {indicator}")
                return True
        
        # Cek apakah ada indikator yang menunjukkan user belum login
        logout_indicators = [
            'a[href*="login"]',
            'button:has-text("Login")',
            'a:has-text("Login")',
            'input[type="password"]',
            'form[action*="login"]',
            'input[name*="password"]',
            'input[id*="password"]'
        ]
        
        for indicator in logout_indicators:
            if page.locator(indicator).count() > 0:
                logger.warning(f"Session invalid - found logout indicator: {indicator}")
                return False
        
        # Cek cookies untuk session
        try:
            cookies = page.context.cookies()
            session_cookies = [c for c in cookies if 'session' in c.get('name', '').lower() or 'auth' in c.get('name', '').lower()]
            if session_cookies:
                logger.info(f"Session valid - found {len(session_cookies)} session cookies")
                return True
        except Exception as e:
            logger.debug(f"Could not check cookies: {e}")
        
        # Jika tidak ada indikator yang jelas, anggap session valid
        logger.info("Session status unclear - assuming valid")
        return True
        
    except Exception as e:
        logger.warning(f"Failed to check session validity: {e}")
        return True  # Default to valid if check fails


def test_form_submission(
    page: Page,
    form_index: int = 0,
    timeout_ms: int = 5000,
    out_dir: str = None,
    safe_mode: bool = True
) -> Dict[str, Any]:
    """
    Test form submission dengan validasi yang lebih komprehensif.
    
    Args:
        page: Playwright page object
        form_index: Index of form to test
        timeout_ms: Timeout untuk menunggu response
        out_dir: Directory untuk menyimpan screenshot (optional)
        safe_mode: Jika True, hanya test form filling tanpa submit untuk menghindari session loss
        
    Returns:
        Test result dictionary dengan detail yang lebih lengkap
    """
    result = {
        'success': False,
        'fill_result': None,
        'response_status': None,
        'has_error_message': False,
        'has_success_message': False,
        'redirected': False,
        'url_changed': False,
        'form_validation_errors': [],
        'network_errors': [],
        'errors': [],
        'screenshot_before_path': None,
        'screenshot_after_path': None
    }
    
    try:
        # Simpan session state sebelum form testing
        session_state = save_session_state(page)
        result['session_state_saved'] = bool(session_state)
        
        # Cek session timeout dan warning jika perlu
        try:
            session_timeout = page.evaluate("""
                () => {
                    // Cek session timeout dari berbagai sumber
                    const sources = [
                        localStorage.getItem('sessionTimeout'),
                        sessionStorage.getItem('sessionTimeout'),
                        localStorage.getItem('authTimeout'),
                        sessionStorage.getItem('authTimeout'),
                        localStorage.getItem('sessionExpiry'),
                        sessionStorage.getItem('sessionExpiry')
                    ];
                    
                    for (let source of sources) {
                        if (source) {
                            const timeout = parseInt(source);
                            if (!isNaN(timeout) && timeout > 0) {
                                return timeout;
                            }
                        }
                    }
                    return null;
                }
            """)
            
            if session_timeout:
                logger.info(f"Session timeout detected: {session_timeout} minutes")
                result['session_timeout'] = session_timeout
                
                # Warning jika session timeout terlalu pendek
                if session_timeout < 30:
                    logger.warning(f"Session timeout is very short: {session_timeout} minutes - may cause session loss")
                    result['warnings'] = result.get('warnings', [])
                    result['warnings'].append(f"Session timeout is very short: {session_timeout} minutes")
        except Exception as e:
            logger.debug(f"Could not check session timeout: {e}")
        
        # Periksa session validity sebelum form testing
        session_valid = check_session_validity(page)
        if not session_valid:
            logger.warning("Session invalid - form submission may cause login redirect")
            result['errors'].append("Session invalid - form submission may cause login redirect")
            result['success'] = False
            return result
        
        # Ambil screenshot sebelum test dan simpan ke file jika out_dir tersedia
        if out_dir:
            try:
                before_path = os.path.join(out_dir, "form_before.png")
                page.screenshot(path=before_path, full_page=True)
                result['screenshot_before_path'] = before_path
            except Exception:
                pass
        
        # Fill the form first
        fill_result = fill_form(page, form_index, submit=False)
        result['fill_result'] = fill_result
        result['submitted'] = fill_result.get('submitted', False)
        
        if fill_result['fields_filled'] == 0:
            result['errors'].append("No fields were filled")
            return result
        
        # Check if we're in safe mode to avoid session loss
        if safe_mode:
            logger.info("🛡️ SAFE MODE ACTIVE - Form filling only, no submission")
            
            # Take screenshot after form filling (before submission)
            if out_dir:
                try:
                    after_path = os.path.join(out_dir, "form_after.png")
                    page.screenshot(path=after_path, full_page=True)
                    result['screenshot_after_path'] = after_path
                    logger.info(f"Screenshot saved to: {after_path}")
                except Exception as e:
                    logger.warning(f"Failed to take screenshot after form filling: {e}")
            
            result['success'] = True
            result['submitted'] = False
            result['safe_mode'] = True
            result['message'] = "Form filled successfully in safe mode (submission skipped to preserve session)"
            logger.info("🛡️ SAFE MODE: Returning result without form submission")
            return result
        
        # Double check session validity before form submission (even in non-safe mode)
        session_still_valid = check_session_validity(page)
        if not session_still_valid:
            logger.warning("Session became invalid before form submission - switching to safe mode")
            result['success'] = True
            result['submitted'] = False
            result['safe_mode'] = True
            result['message'] = "Form filled successfully (submission skipped due to invalid session)"
            return result
        
        # Additional session validation - cek cookies dan localStorage
        try:
            # Cek apakah ada session cookies yang valid
            cookies = page.context.cookies()
            session_cookies = [c for c in cookies if 'session' in c.get('name', '').lower() or 'auth' in c.get('name', '').lower()]
            
            if not session_cookies:
                logger.warning("No session cookies found - form submission may cause login redirect")
                result['warnings'] = result.get('warnings', [])
                result['warnings'].append("No session cookies found - form submission may cause login redirect")
            
            # Cek localStorage untuk session data
            session_data = page.evaluate("""
                () => {
                    const sessionKeys = ['session', 'auth', 'token', 'user', 'login'];
                    const found = [];
                    for (let key of sessionKeys) {
                        if (localStorage.getItem(key) || sessionStorage.getItem(key)) {
                            found.push(key);
                        }
                    }
                    return found;
                }
            """)
            
            if not session_data:
                logger.warning("No session data found in localStorage/sessionStorage - form submission may cause login redirect")
                result['warnings'] = result.get('warnings', [])
                result['warnings'].append("No session data found - form submission may cause login redirect")
            
        except Exception as e:
            logger.debug(f"Could not check session data: {e}")
        
        # If form was already submitted in fill_form, we're done
        if fill_result.get('submitted'):
            logger.info("Form was already submitted in fill_form")
            result['submitted'] = True
        else:
            # Form was filled but not submitted, so we need to submit it
            logger.info("Form was filled but not submitted, attempting submission...")
            # The submission logic is already handled in the main flow below
        
        # Simpan URL awal
        initial_url = page.url
        
        # Monitor network requests untuk error
        network_errors = []
        def handle_request_failed(request):
            network_errors.append({
                'url': request.url,
                'method': request.method,
                'failure': str(request.failure)
            })
        
        page.on("requestfailed", handle_request_failed)
        
        # Submit form only if not already submitted
        if not result.get('submitted', False):
            logger.info("Form not yet submitted, attempting submission...")
            
            # Final session check sebelum submission
            final_session_check = check_session_validity(page)
            if not final_session_check:
                logger.warning("Final session check failed - aborting form submission to prevent login redirect")
                result['success'] = True
                result['submitted'] = False
                result['safe_mode'] = True
                result['message'] = "Form submission aborted to prevent login redirect (session invalid)"
                return result
            
            try:
                forms = page.locator('form')
                form_count = forms.count()
                logger.info(f"Found {form_count} forms for final submission")
                
                if form_count == 0:
                    logger.warning("No forms found for final submission, trying alternative selectors...")
                    
                    # Try alternative form selectors
                    alt_form_selectors = [
                        'form',
                        '[role="form"]',
                        '.form',
                        '#form',
                        'div[class*="form"]',
                        'section[class*="form"]'
                    ]
                    
                    for selector in alt_form_selectors:
                        alt_forms = page.locator(selector)
                        count = alt_forms.count()
                        if count > 0:
                            logger.info(f"Found {count} elements with selector '{selector}' for final submission")
                            forms = alt_forms
                            form_count = count
                            break
                
                if form_count == 0:
                    result['errors'].append("No forms found for final submission")
                    logger.error("No forms found for final submission with any selector")
                    return result
                    
                if form_count <= form_index:
                    result['errors'].append(f"Form index {form_index} not found for final submission (only {form_count} forms available)")
                    logger.error(f"Form index {form_index} not found for final submission (only {form_count} forms available)")
                    return result
                    
                form = forms.nth(form_index)
                logger.info(f"Using form {form_index} for final submission with {form_count} total forms available")
                
                submit_button = form.locator('button[type="submit"], input[type="submit"]').first
                
                if submit_button.count() > 0:
                    # Submit form
                    submit_button.click()
                    result['submitted'] = True
                    logger.info("Form submitted via submit button in final submission")
                    
                    # Wait for response dengan timeout
                    try:
                        page.wait_for_load_state("networkidle", timeout=timeout_ms)
                    except Exception:
                        # Fallback jika networkidle timeout
                        page.wait_for_timeout(2000)
                else:
                    # Try to submit via form
                    form.evaluate('form => form.submit()')
                    result['submitted'] = True
                    logger.info("Form submitted via form.submit() in final submission")
                    
            except Exception as e:
                result['errors'].append(f"Failed to submit form in final submission: {str(e)}")
                logger.error(f"Failed to submit form in final submission: {e}")
                return result
        else:
            logger.info("Form already submitted, skipping final submission")
        
        # Simpan screenshot setelah submit ke file jika out_dir tersedia
        if out_dir:
            try:
                after_path = os.path.join(out_dir, "form_after.png")
                page.screenshot(path=after_path, full_page=True)
                result['screenshot_after_path'] = after_path
            except Exception:
                pass
        
        # Check URL change and detect login redirect
        result['url_changed'] = page.url != initial_url
        result['redirected'] = result['url_changed']
        
        # Check if redirected to login page
        current_url = page.url.lower()
        login_indicators = [
            '/login', '/signin', '/auth', '/masuk', '/admin/login',
            'login', 'signin', 'authentication'
        ]
        
        is_login_redirect = any(indicator in current_url for indicator in login_indicators)
        result['redirected_to_login'] = is_login_redirect
        
        # Double check session validity after form submission
        if not is_login_redirect:
            session_still_valid = check_session_validity(page)
            if not session_still_valid:
                logger.warning("Session became invalid after form submission")
                result['errors'].append("Session became invalid after form submission")
                result['success'] = False
                return result
        else:
            # Jika redirect ke login, coba deteksi penyebabnya
            logger.info("Analyzing login redirect causes...")
            
            # Cek apakah ada error message yang menunjukkan penyebab
            error_selectors = [
                '.error', '.alert-danger', '.invalid-feedback', '.is-invalid', 
                '[role="alert"]', '.error-message', '.field-error', '.validation-error',
                '.form-error', '.input-error', '.session-error', '.auth-error',
                '.login-error', '.timeout-error', '.expired-error'
            ]
            
            error_found = False
            for selector in error_selectors:
                error_messages = page.locator(selector)
                if error_messages.count() > 0:
                    for i in range(min(error_messages.count(), 3)):
                        error_text = error_messages.nth(i).text_content()
                        if error_text and error_text.strip():
                            logger.info(f"Error message found with selector '{selector}': {error_text.strip()}")
                            result['login_redirect_reason'] = error_text.strip()
                            error_found = True
                            break
                if error_found:
                    break
            
            # Jika tidak ada error message, cek URL dan content untuk indikator
            if not error_found:
                current_url = page.url.lower()
                page_content = page.content().lower()
                
                # Cek indikator session timeout
                timeout_indicators = [
                    'session expired', 'session timeout', 'session invalid',
                    'login expired', 'authentication expired', 'token expired',
                    'sesi berakhir', 'sesi expired', 'waktu habis'
                ]
                
                for indicator in timeout_indicators:
                    if indicator in page_content:
                        logger.info(f"Session timeout indicator found: {indicator}")
                        result['login_redirect_reason'] = f"Session timeout: {indicator}"
                        error_found = True
                        break
                
                # Cek indikator authentication error
                if not error_found:
                    auth_indicators = [
                        'authentication required', 'login required', 'unauthorized',
                        'access denied', 'permission denied', 'not authenticated',
                        'harus login', 'perlu login', 'akses ditolak'
                    ]
                    
                    for indicator in auth_indicators:
                        if indicator in page_content:
                            logger.info(f"Authentication error indicator found: {indicator}")
                            result['login_redirect_reason'] = f"Authentication error: {indicator}"
                            error_found = True
                            break
                
                # Cek URL untuk indikator
                if not error_found:
                    if 'timeout' in current_url:
                        result['login_redirect_reason'] = "Session timeout detected in URL"
                    elif 'expired' in current_url:
                        result['login_redirect_reason'] = "Session expired detected in URL"
                    elif 'unauthorized' in current_url:
                        result['login_redirect_reason'] = "Unauthorized access detected in URL"
                    else:
                        result['login_redirect_reason'] = "Redirect to login page - no specific error message found"
        
        if is_login_redirect:
            logger.warning(f"Form submission redirected to login page: {page.url}")
            
            # Coba pulihkan session state jika tersimpan
            if session_state:
                logger.info("Attempting to restore session state...")
                restore_success = restore_session_state(page, session_state)
                if restore_success:
                    logger.info("Session state restored successfully")
                    result['session_restored'] = True
                    # Coba navigasi kembali ke halaman asli
                    try:
                        page.goto(initial_url, wait_until="load", timeout=5000)
                        logger.info(f"Navigated back to original page: {initial_url}")
                    except Exception as e:
                        logger.warning(f"Failed to navigate back to original page: {e}")
                else:
                    logger.warning("Failed to restore session state")
                    result['session_restored'] = False
            
            # Analisis penyebab redirect ke login
            redirect_reason = result.get('login_redirect_reason', 'Unknown')
            logger.info(f"Login redirect reason: {redirect_reason}")
            
            # Coba deteksi penyebab yang lebih spesifik
            if redirect_reason == 'Unknown':
                # Cek apakah ada indikator session timeout di halaman
                try:
                    timeout_indicators = page.evaluate("""
                        () => {
                            const indicators = [
                                'session expired', 'session timeout', 'login expired',
                                'authentication expired', 'token expired', 'sesi berakhir',
                                'waktu habis', 'session invalid', 'login required'
                            ];
                            
                            const pageText = document.body.innerText.toLowerCase();
                            for (let indicator of indicators) {
                                if (pageText.includes(indicator)) {
                                    return indicator;
                                }
                            }
                            return null;
                        }
                    """)
                    
                    if timeout_indicators:
                        redirect_reason = f"Session timeout detected: {timeout_indicators}"
                        result['login_redirect_reason'] = redirect_reason
                        logger.info(f"Enhanced redirect reason: {redirect_reason}")
                except Exception as e:
                    logger.debug(f"Could not detect timeout indicators: {e}")
            
            result['errors'].append(f"Form submission caused redirect to login page - possible session loss. Reason: {redirect_reason}")
            result['success'] = False
            return result
        
        # Check for validation errors (lebih comprehensive)
        validation_error_selectors = [
            '.error', '.alert-danger', '.invalid-feedback', '.is-invalid',
            '[role="alert"]', '.error-message', '.field-error',
            '.validation-error', '.form-error', '.input-error',
            '[class*="error"]', '[class*="invalid"]'
        ]
        
        for selector in validation_error_selectors:
            elements = page.locator(selector)
            if elements.count() > 0:
                for i in range(min(elements.count(), 5)):  # Limit to 5 errors
                    error_text = elements.nth(i).text_content()
                    if error_text and error_text.strip():
                        result['form_validation_errors'].append({
                            'selector': selector,
                            'text': error_text.strip()[:200]  # Limit text length
                        })
                result['has_error_message'] = True
        
        # Check for success indicators (lebih comprehensive)
        success_selectors = [
            '.success', '.alert-success', '.success-message',
            '[role="status"]', '.form-success', '.submission-success',
            '.thank-you', '.confirmation', '[class*="success"]'
        ]
        
        for selector in success_selectors:
            elements = page.locator(selector)
            if elements.count() > 0:
                for i in range(min(elements.count(), 3)):  # Limit to 3 success messages
                    success_text = elements.nth(i).text_content()
                    if success_text and success_text.strip():
                        result['has_success_message'] = True
                        break
                if result['has_success_message']:
                    break
        
        # Check for common success indicators in text
        page_content = page.content()
        success_indicators = [
            'thank you', 'success', 'submitted', 'received',
            'confirmation', 'complete', 'done'
        ]
        
        if any(indicator in page_content.lower() for indicator in success_indicators):
            result['has_success_message'] = True
        
        # Simpan network errors
        result['network_errors'] = network_errors
        
        # Determine overall success
        if result['has_error_message'] or network_errors:
            result['success'] = False
        elif result['has_success_message'] or result['redirected']:
            result['success'] = True
        else:
            # Ambiguous case - check if form is still there (might indicate failure)
            remaining_forms = page.locator('form').count()
            if remaining_forms == 0:
                result['success'] = True  # Form disappeared, likely successful
            else:
                result['success'] = False  # Form still there, might have failed
    
    except Exception as e:
        result['errors'].append(f"Form test error: {str(e)}")
        logger.error(f"Form submission test failed: {e}")
    
    return result


def perform_login(
    page: Page,
    login_url: str,
    username: str,
    password: str,
    success_indicator: Optional[str] = None,
    timeout_ms: int = 10000
) -> Dict[str, Any]:
    """
    Lakukan proses login menggunakan heuristik umum.

    Args:
        page: Objek Playwright Page
        login_url: URL halaman login
        username: Nilai username/email
        password: Nilai password
        success_indicator: Selector CSS atau teks yang menandakan login berhasil
        timeout_ms: Timeout operasi dalam milidetik

    Returns:
        Hasil proses login berisi status dan rincian langkah.
    """
    result: Dict[str, Any] = {
        "navigated": False,
        "filled_username": False,
        "filled_password": False,
        "clicked_submit": False,
        "success": False,
        "error": None
    }

    try:
        # Buka halaman login
        page.goto(login_url, wait_until="load", timeout=timeout_ms)
        page.wait_for_timeout(500)
        result["navigated"] = True

        # Cari field username/email (prioritaskan selector eksplisit jika ada di dataset global)
        username_locators = [
            'input[type="email"]',
            'input[name*="email" i]',
            'input[id*="email" i]',
            'input[name*="user" i]',
            'input[id*="user" i]',
            'input[type="text"]'
        ]
        password_locators = [
            'input[type="password"]',
            'input[name*="pass" i]',
            'input[id*="pass" i]'
        ]

        def find_first(locators: List[str]) -> Optional[Locator]:
            for sel in locators:
                loc = page.locator(sel).first
                try:
                    if loc.count() > 0:
                        return loc
                except Exception:
                    continue
            return None

        user_field = find_first(username_locators)
        pass_field = find_first(password_locators)

        if user_field is None or pass_field is None:
            raise RuntimeError("Username/password field not found on login page")

        try:
            user_field.fill(username)
            result["filled_username"] = True
        except Exception as e:
            logger.warning(f"Failed to fill username: {e}")

        try:
            pass_field.fill(password)
            result["filled_password"] = True
        except Exception as e:
            logger.warning(f"Failed to fill password: {e}")

        # Klik submit
        submit_locators = [
            'button[type="submit"]',
            'input[type="submit"]',
            'button:has-text("Login")',
            'button:has-text("Sign in")',
            'button:has-text("Masuk")'
        ]
        submit_btn = find_first(submit_locators)
        if submit_btn is None:
            # fallback: tekan Enter pada password field
            pass_field.press('Enter')
            result["clicked_submit"] = True
        else:
            submit_btn.click()
            result["clicked_submit"] = True

        # Tunggu settle setelah submit
        try:
            page.wait_for_load_state("networkidle", timeout=timeout_ms)
        except Exception:
            page.wait_for_timeout(1000)
        
        # Simpan session/cookies untuk persistence
        try:
            # Simpan cookies ke context untuk session persistence
            cookies = page.context.cookies()
            logger.info(f"Session cookies saved: {len(cookies)} cookies")
            
            # Simpan session timeout information
            session_timeout = page.evaluate("""
                () => {
                    // Cek session timeout dari localStorage atau sessionStorage
                    const sessionTimeout = localStorage.getItem('sessionTimeout') || 
                                         sessionStorage.getItem('sessionTimeout') ||
                                         localStorage.getItem('authTimeout') ||
                                         sessionStorage.getItem('authTimeout');
                    return sessionTimeout ? parseInt(sessionTimeout) : null;
                }
            """)
            
            if session_timeout:
                logger.info(f"Session timeout detected: {session_timeout} minutes")
        except Exception as e:
            logger.warning(f"Failed to save session cookies: {e}")

        # Verifikasi sukses login bila ada indikator
        if success_indicator:
            # Coba sebagai selector CSS dulu
            try:
                if page.locator(success_indicator).count() > 0:
                    result["success"] = True
                else:
                    # Fallback: cek teks pada halaman
                    content = page.content()
                    result["success"] = success_indicator in (content or "")
            except Exception:
                content = page.content()
                result["success"] = success_indicator in (content or "")
        else:
            # Tanpa indikator spesifik, anggap sukses jika tidak ada error umum di halaman
            error_candidates = ['.error', '.alert-danger', '.invalid-feedback']
            has_errors = any(page.locator(sel).count() > 0 for sel in error_candidates)
            result["success"] = not has_errors

    except Exception as e:
        result["error"] = str(e)
        logger.error(f"Login error: {e}")

    return result
