"""Form detection and automated testing heuristics."""

from playwright.sync_api import Page, Locator
from typing import Dict, Any, List, Optional
import logging
import os

logger = logging.getLogger(__name__)


def detect_forms(page: Page) -> List[Dict[str, Any]]:
    """
    Detect all forms on the page.
    
    Args:
        page: Playwright page object
        
    Returns:
        List of form information dictionaries
    """
    forms = []
    form_elements = page.locator('form')
    
    for i in range(form_elements.count()):
        form = form_elements.nth(i)
        
        form_info = {
            'index': i,
            'action': form.get_attribute('action') or '',
            'method': form.get_attribute('method') or 'GET',
            'inputs': []
        }
        
        # Find all inputs in this form
        inputs = form.locator('input, textarea, select')
        for j in range(inputs.count()):
            input_elem = inputs.nth(j)
            input_type = input_elem.get_attribute('type') or 'text'
            
            # Skip buttons and submits for now
            if input_type in ['submit', 'button', 'image', 'reset']:
                continue
            
            input_info = {
                'type': input_type,
                'name': input_elem.get_attribute('name') or '',
                'id': input_elem.get_attribute('id') or '',
                'required': input_elem.get_attribute('required') is not None,
                'placeholder': input_elem.get_attribute('placeholder') or ''
            }
            form_info['inputs'].append(input_info)
        
        forms.append(form_info)
    
    return forms


def generate_dummy_data(input_type: str, name: str = '', placeholder: str = '') -> str:
    """
    Generate dummy data based on input type and context.
    
    Args:
        input_type: HTML input type
        name: Input name attribute
        placeholder: Input placeholder text
        
    Returns:
        Dummy value string
    """
    name_lower = name.lower()
    placeholder_lower = placeholder.lower()
    
    # Email detection
    if input_type == 'email' or 'email' in name_lower or 'email' in placeholder_lower:
        return 'test@example.com'
    
    # Password detection
    if input_type == 'password' or 'password' in name_lower or 'pass' in name_lower:
        return 'Test123!@#'
    
    # Phone detection
    if input_type == 'tel' or 'phone' in name_lower or 'tel' in name_lower:
        return '+1234567890'
    
    # Number detection
    if input_type == 'number':
        return '42'
    
    # Date detection
    if input_type == 'date':
        return '2024-01-15'
    
    # Time detection
    if input_type == 'time':
        return '14:30'
    
    # URL detection
    if input_type == 'url' or 'url' in name_lower or 'website' in name_lower:
        return 'https://example.com'
    
    # Name detection
    if 'name' in name_lower or 'nama' in name_lower:
        if 'first' in name_lower or 'depan' in name_lower:
            return 'John'
        elif 'last' in name_lower or 'belakang' in name_lower:
            return 'Doe'
        else:
            return 'John Doe'
    
    # Address detection
    if 'address' in name_lower or 'alamat' in name_lower:
        return '123 Main Street, City, State 12345'
    
    # Textarea or message
    if input_type == 'textarea' or 'message' in name_lower or 'comment' in name_lower:
        return 'This is a test message generated by automated testing.'
    
    # Default text
    return 'Test Input'


def fill_form(
    page: Page,
    form_index: int = 0,
    submit: bool = False
) -> Dict[str, Any]:
    """
    Automatically fill a form with dummy data.
    
    Args:
        page: Playwright page object
        form_index: Index of form to fill (default: 0)
        submit: Whether to submit the form (default: False)
        
    Returns:
        Dictionary with fill results
    """
    result = {
        'form_index': form_index,
        'fields_filled': 0,
        'fields_failed': 0,
        'submitted': False,
        'errors': []
    }
    
    try:
        # Enhanced form detection with better debugging
        forms = page.locator('form')
        form_count = forms.count()
        logger.info(f"Found {form_count} forms on page")
        
        if form_count == 0:
            logger.warning("No forms found, trying alternative selectors...")
            
            # Try alternative form selectors
            alt_form_selectors = [
                'form',
                '[role="form"]',
                '.form',
                '#form',
                'div[class*="form"]',
                'section[class*="form"]'
            ]
            
            for selector in alt_form_selectors:
                alt_forms = page.locator(selector)
                count = alt_forms.count()
                if count > 0:
                    logger.info(f"Found {count} elements with selector '{selector}'")
                    forms = alt_forms
                    form_count = count
                    break
        
        if form_count == 0:
            result['errors'].append("No forms found on page")
            logger.error("No forms found with any selector")
            return result
        
        if form_count <= form_index:
            result['errors'].append(f"Form index {form_index} not found (only {form_count} forms available)")
            logger.error(f"Form index {form_index} not found (only {form_count} forms available)")
            return result
        
        form = forms.nth(form_index)
        logger.info(f"Using form {form_index} with {form_count} total forms available")
        
        # Fill text inputs - expanded selectors for modern frameworks
        text_input_selectors = [
            'input[type="text"]',
            'input[type="email"]', 
            'input[type="tel"]',
            'input[type="url"]',
            'input[type="search"]',
            'input:not([type])',
            'input[type="number"]',
            'input[type="date"]',
            'input[type="time"]',
            'input[type="datetime-local"]',
            'input[type="month"]',
            'input[type="week"]',
            'input[type="color"]',
            'input[type="range"]',
            'input[type="file"]',
            'input[type="checkbox"]',
            'input[type="radio"]',
            'input[type="hidden"]',
            'input',  # Catch all inputs
            'textarea',
            'select'
        ]
        
        # Try each selector individually for better debugging
        total_inputs = 0
        for selector in text_input_selectors:
            try:
                inputs = form.locator(selector)
                count = inputs.count()
                if count > 0:
                    logger.info(f"Found {count} elements with selector '{selector}'")
                    total_inputs += count
            except Exception as e:
                logger.debug(f"Error with selector '{selector}': {e}")
        
        logger.info(f"Total inputs found: {total_inputs}")
        
        # Use comprehensive selector with better debugging
        text_inputs = form.locator('input, textarea, select')
        logger.info(f"Found {text_inputs.count()} total inputs in form {form_index}")
        
        # Additional debugging - check if form is actually found
        if text_inputs.count() == 0:
            logger.warning(f"No inputs found in form {form_index}, trying alternative selectors...")
            
            # Try alternative selectors
            alt_selectors = [
                'input:not([type="hidden"])',
                'input[type="text"], input[type="email"], input[type="password"], input[type="number"], input[type="date"], input[type="time"]',
                'textarea',
                'select'
            ]
            
            for alt_selector in alt_selectors:
                alt_inputs = form.locator(alt_selector)
                count = alt_inputs.count()
                if count > 0:
                    logger.info(f"Found {count} inputs with alternative selector: {alt_selector}")
                    text_inputs = alt_inputs
                    break
        
        for i in range(text_inputs.count()):
            try:
                input_elem = text_inputs.nth(i)
                name = input_elem.get_attribute('name') or ''
                input_type = input_elem.get_attribute('type') or 'text'
                placeholder = input_elem.get_attribute('placeholder') or ''
                
                # Get tag name safely
                try:
                    tag_name = input_elem.evaluate('el => el.tagName').lower()
                except Exception:
                    tag_name = 'unknown'
                
                logger.info(f"Processing input {i}: tag={tag_name}, type={input_type}, name={name}")
                
                # Skip hidden inputs
                if input_type == 'hidden':
                    logger.debug(f"Skipping hidden input: {name}")
                    continue
                
                # Check if input is visible and enabled with better error handling
                try:
                    is_visible = input_elem.is_visible()
                    is_disabled = input_elem.is_disabled()
                    logger.info(f"Input {i}: visible={is_visible}, disabled={is_disabled}")
                    
                    if not is_visible:
                        logger.info(f"Skipping invisible input: {name}")
                        continue
                        
                    if is_disabled:
                        logger.info(f"Skipping disabled input: {name}")
                        continue
                        
                except Exception as e:
                    logger.warning(f"Could not check visibility/disabled for input {i}: {e}")
                    # Continue anyway, might be a framework issue
                    logger.info(f"Attempting to fill input {i} anyway...")
                
                # Handle different input types
                if tag_name == 'select':
                    # Handle select elements
                    options = input_elem.locator('option')
                    if options.count() > 1:
                        input_elem.select_option(index=1)
                        result['fields_filled'] += 1
                        logger.info(f"Selected option in select '{name}'")
                elif input_type in ['checkbox', 'radio']:
                    # Handle checkboxes and radio buttons
                    if not input_elem.is_checked():
                        input_elem.check()
                        result['fields_filled'] += 1
                        logger.info(f"Checked {input_type} '{name}'")
                elif input_type == 'file':
                    # Skip file inputs for now
                    logger.debug(f"Skipping file input: {name}")
                    continue
                else:
                    # Handle text inputs
                    value = generate_dummy_data(input_type, name, placeholder)
                    input_elem.fill(value)
                    result['fields_filled'] += 1
                    logger.info(f"Filled input '{name}' (type: {input_type}) with '{value}'")
                    
            except Exception as e:
                result['fields_failed'] += 1
                result['errors'].append(f"Failed to fill input {i}: {str(e)}")
                logger.error(f"Failed to fill input {i}: {e}")
        
        # All input types are now handled in the main loop above
        
        # Submit if requested
        if submit:
            try:
                # Look for submit button with more selectors
                submit_selectors = [
                    'button[type="submit"]',
                    'input[type="submit"]',
                    'button:has-text("Submit")',
                    'button:has-text("Submit order")',
                    'button:has-text("Send")',
                    'button:has-text("Post")',
                    'button:has-text("Save")',
                    'button:has-text("Send Message")',
                    'button:has-text("Submit Form")',
                    'button:not([type])',  # Button without type (defaults to submit)
                    'input[type="button"]:has-text("Submit")',
                    'button'  # Any button in form (fallback)
                ]
                
                submit_button = None
                for selector in submit_selectors:
                    try:
                        btn = form.locator(selector).first
                        if btn.count() > 0 and btn.is_visible() and not btn.is_disabled():
                            submit_button = btn
                            logger.info(f"Found submit button with selector: {selector}")
                            break
                    except Exception:
                        continue
                
                if submit_button:
                    submit_button.click()
                    result['submitted'] = True
                    logger.info("Form submitted via submit button")
                    page.wait_for_timeout(1000)  # Wait for submission
                else:
                    # Try to submit via form
                    form.evaluate('form => form.submit()')
                    result['submitted'] = True
                    logger.info("Form submitted via form.submit()")
            except Exception as e:
                result['errors'].append(f"Failed to submit form: {str(e)}")
                logger.error(f"Failed to submit form: {e}")
        
        logger.info(f"Form filling completed: {result['fields_filled']} filled, {result['fields_failed']} failed")
        
        # If no fields were filled, try a more aggressive approach
        if result['fields_filled'] == 0:
            logger.warning("No fields were filled with standard approach, trying aggressive detection...")
            
            # Try to find any input on the page, not just in form
            page_inputs = page.locator('input:not([type="hidden"]), textarea, select')
            logger.info(f"Found {page_inputs.count()} inputs on entire page")
            
            # Also try to find form-like containers
            form_containers = page.locator('div[class*="form"], section[class*="form"], div[class*="field"], div[class*="input"]')
            logger.info(f"Found {form_containers.count()} form-like containers")
            
            for i in range(min(page_inputs.count(), 20)):  # Increased limit
                try:
                    input_elem = page_inputs.nth(i)
                    name = input_elem.get_attribute('name') or f'input_{i}'
                    input_type = input_elem.get_attribute('type') or 'text'
                    placeholder = input_elem.get_attribute('placeholder') or ''
                    
                    # Check if it's visible and not disabled
                    if input_elem.is_visible() and not input_elem.is_disabled():
                        try:
                            if input_type in ['checkbox', 'radio']:
                                if not input_elem.is_checked():
                                    input_elem.check()
                                    result['fields_filled'] += 1
                                    logger.info(f"Aggressively filled {input_type} '{name}'")
                            elif input_type == 'file':
                                # Skip file inputs for now
                                logger.debug(f"Skipping file input: {name}")
                                continue
                            else:
                                value = generate_dummy_data(input_type, name, placeholder)
                                input_elem.fill(value)
                                result['fields_filled'] += 1
                                logger.info(f"Aggressively filled input '{name}' with '{value}'")
                        except Exception as e:
                            logger.debug(f"Could not fill input {i} aggressively: {e}")
                except Exception as e:
                    logger.debug(f"Error in aggressive filling for input {i}: {e}")
            
            logger.info(f"Aggressive filling completed: {result['fields_filled']} filled")
    
    except Exception as e:
        result['errors'].append(f"Form filling error: {str(e)}")
        logger.error(f"Form filling error: {e}")
    
    return result


def test_form_submission(
    page: Page,
    form_index: int = 0,
    timeout_ms: int = 5000,
    out_dir: str = None,
    safe_mode: bool = True
) -> Dict[str, Any]:
    """
    Test form submission dengan validasi yang lebih komprehensif.
    
    Args:
        page: Playwright page object
        form_index: Index of form to test
        timeout_ms: Timeout untuk menunggu response
        out_dir: Directory untuk menyimpan screenshot (optional)
        safe_mode: Jika True, hanya test form filling tanpa submit untuk menghindari session loss
        
    Returns:
        Test result dictionary dengan detail yang lebih lengkap
    """
    result = {
        'success': False,
        'fill_result': None,
        'response_status': None,
        'has_error_message': False,
        'has_success_message': False,
        'redirected': False,
        'url_changed': False,
        'form_validation_errors': [],
        'network_errors': [],
        'errors': [],
        'screenshot_before_path': None,
        'screenshot_after_path': None
    }
    
    try:
        # Ambil screenshot sebelum test dan simpan ke file jika out_dir tersedia
        if out_dir:
            try:
                before_path = os.path.join(out_dir, "form_before.png")
                page.screenshot(path=before_path, full_page=True)
                result['screenshot_before_path'] = before_path
            except Exception:
                pass
        
        # Fill the form first
        fill_result = fill_form(page, form_index, submit=False)
        result['fill_result'] = fill_result
        result['submitted'] = fill_result.get('submitted', False)
        
        if fill_result['fields_filled'] == 0:
            result['errors'].append("No fields were filled")
            return result
        
        # Check if we're in safe mode to avoid session loss
        if safe_mode:
            logger.info("Safe mode enabled - only testing form filling, skipping submission to avoid session loss")
            
            # Take screenshot after form filling (before submission)
            if out_dir:
                try:
                    after_path = os.path.join(out_dir, "form_after.png")
                    page.screenshot(path=after_path, full_page=True)
                    result['screenshot_after_path'] = after_path
                    logger.info(f"Screenshot saved to: {after_path}")
                except Exception as e:
                    logger.warning(f"Failed to take screenshot after form filling: {e}")
            
            result['success'] = True
            result['submitted'] = False
            result['safe_mode'] = True
            result['message'] = "Form filled successfully in safe mode (submission skipped to preserve session)"
            return result
        
        # If form was already submitted in fill_form, we're done
        if fill_result.get('submitted'):
            logger.info("Form was already submitted in fill_form")
            result['submitted'] = True
        else:
            # Form was filled but not submitted, so we need to submit it
            logger.info("Form was filled but not submitted, attempting submission...")
            # The submission logic is already handled in the main flow below
        
        # Simpan URL awal
        initial_url = page.url
        
        # Monitor network requests untuk error
        network_errors = []
        def handle_request_failed(request):
            network_errors.append({
                'url': request.url,
                'method': request.method,
                'failure': str(request.failure)
            })
        
        page.on("requestfailed", handle_request_failed)
        
        # Submit form only if not already submitted
        if not result.get('submitted', False):
            try:
                forms = page.locator('form')
                form_count = forms.count()
                logger.info(f"Found {form_count} forms for final submission")
                
                if form_count == 0:
                    logger.warning("No forms found for final submission, trying alternative selectors...")
                    
                    # Try alternative form selectors
                    alt_form_selectors = [
                        'form',
                        '[role="form"]',
                        '.form',
                        '#form',
                        'div[class*="form"]',
                        'section[class*="form"]'
                    ]
                    
                    for selector in alt_form_selectors:
                        alt_forms = page.locator(selector)
                        count = alt_forms.count()
                        if count > 0:
                            logger.info(f"Found {count} elements with selector '{selector}' for final submission")
                            forms = alt_forms
                            form_count = count
                            break
                
                if form_count == 0:
                    result['errors'].append("No forms found for final submission")
                    logger.error("No forms found for final submission with any selector")
                    return result
                    
                if form_count <= form_index:
                    result['errors'].append(f"Form index {form_index} not found for final submission (only {form_count} forms available)")
                    logger.error(f"Form index {form_index} not found for final submission (only {form_count} forms available)")
                    return result
                    
                form = forms.nth(form_index)
                logger.info(f"Using form {form_index} for final submission with {form_count} total forms available")
                
                submit_button = form.locator('button[type="submit"], input[type="submit"]').first
                
                if submit_button.count() > 0:
                    # Submit form
                    submit_button.click()
                    result['submitted'] = True
                    logger.info("Form submitted via submit button in final submission")
                    
                    # Wait for response dengan timeout
                    try:
                        page.wait_for_load_state("networkidle", timeout=timeout_ms)
                    except Exception:
                        # Fallback jika networkidle timeout
                        page.wait_for_timeout(2000)
                else:
                    # Try to submit via form
                    form.evaluate('form => form.submit()')
                    result['submitted'] = True
                    logger.info("Form submitted via form.submit() in final submission")
                    
            except Exception as e:
                result['errors'].append(f"Failed to submit form in final submission: {str(e)}")
                logger.error(f"Failed to submit form in final submission: {e}")
                return result
        else:
            logger.info("Form already submitted, skipping final submission")
        
        # Simpan screenshot setelah submit ke file jika out_dir tersedia
        if out_dir:
            try:
                after_path = os.path.join(out_dir, "form_after.png")
                page.screenshot(path=after_path, full_page=True)
                result['screenshot_after_path'] = after_path
            except Exception:
                pass
        
        # Check URL change and detect login redirect
        result['url_changed'] = page.url != initial_url
        result['redirected'] = result['url_changed']
        
        # Check if redirected to login page
        current_url = page.url.lower()
        login_indicators = [
            '/login', '/signin', '/auth', '/masuk', '/admin/login',
            'login', 'signin', 'authentication'
        ]
        
        is_login_redirect = any(indicator in current_url for indicator in login_indicators)
        result['redirected_to_login'] = is_login_redirect
        
        if is_login_redirect:
            logger.warning(f"Form submission redirected to login page: {page.url}")
            result['errors'].append("Form submission caused redirect to login page - possible session loss")
            result['success'] = False
            return result
        
        # Check for validation errors (lebih comprehensive)
        validation_error_selectors = [
            '.error', '.alert-danger', '.invalid-feedback', '.is-invalid',
            '[role="alert"]', '.error-message', '.field-error',
            '.validation-error', '.form-error', '.input-error',
            '[class*="error"]', '[class*="invalid"]'
        ]
        
        for selector in validation_error_selectors:
            elements = page.locator(selector)
            if elements.count() > 0:
                for i in range(min(elements.count(), 5)):  # Limit to 5 errors
                    error_text = elements.nth(i).text_content()
                    if error_text and error_text.strip():
                        result['form_validation_errors'].append({
                            'selector': selector,
                            'text': error_text.strip()[:200]  # Limit text length
                        })
                result['has_error_message'] = True
        
        # Check for success indicators (lebih comprehensive)
        success_selectors = [
            '.success', '.alert-success', '.success-message',
            '[role="status"]', '.form-success', '.submission-success',
            '.thank-you', '.confirmation', '[class*="success"]'
        ]
        
        for selector in success_selectors:
            elements = page.locator(selector)
            if elements.count() > 0:
                for i in range(min(elements.count(), 3)):  # Limit to 3 success messages
                    success_text = elements.nth(i).text_content()
                    if success_text and success_text.strip():
                        result['has_success_message'] = True
                        break
                if result['has_success_message']:
                    break
        
        # Check for common success indicators in text
        page_content = page.content()
        success_indicators = [
            'thank you', 'success', 'submitted', 'received',
            'confirmation', 'complete', 'done'
        ]
        
        if any(indicator in page_content.lower() for indicator in success_indicators):
            result['has_success_message'] = True
        
        # Simpan network errors
        result['network_errors'] = network_errors
        
        # Determine overall success
        if result['has_error_message'] or network_errors:
            result['success'] = False
        elif result['has_success_message'] or result['redirected']:
            result['success'] = True
        else:
            # Ambiguous case - check if form is still there (might indicate failure)
            remaining_forms = page.locator('form').count()
            if remaining_forms == 0:
                result['success'] = True  # Form disappeared, likely successful
            else:
                result['success'] = False  # Form still there, might have failed
    
    except Exception as e:
        result['errors'].append(f"Form test error: {str(e)}")
        logger.error(f"Form submission test failed: {e}")
    
    return result


def perform_login(
    page: Page,
    login_url: str,
    username: str,
    password: str,
    success_indicator: Optional[str] = None,
    timeout_ms: int = 10000
) -> Dict[str, Any]:
    """
    Lakukan proses login menggunakan heuristik umum.

    Args:
        page: Objek Playwright Page
        login_url: URL halaman login
        username: Nilai username/email
        password: Nilai password
        success_indicator: Selector CSS atau teks yang menandakan login berhasil
        timeout_ms: Timeout operasi dalam milidetik

    Returns:
        Hasil proses login berisi status dan rincian langkah.
    """
    result: Dict[str, Any] = {
        "navigated": False,
        "filled_username": False,
        "filled_password": False,
        "clicked_submit": False,
        "success": False,
        "error": None
    }

    try:
        # Buka halaman login
        page.goto(login_url, wait_until="load", timeout=timeout_ms)
        page.wait_for_timeout(500)
        result["navigated"] = True

        # Cari field username/email (prioritaskan selector eksplisit jika ada di dataset global)
        username_locators = [
            'input[type="email"]',
            'input[name*="email" i]',
            'input[id*="email" i]',
            'input[name*="user" i]',
            'input[id*="user" i]',
            'input[type="text"]'
        ]
        password_locators = [
            'input[type="password"]',
            'input[name*="pass" i]',
            'input[id*="pass" i]'
        ]

        def find_first(locators: List[str]) -> Optional[Locator]:
            for sel in locators:
                loc = page.locator(sel).first
                try:
                    if loc.count() > 0:
                        return loc
                except Exception:
                    continue
            return None

        user_field = find_first(username_locators)
        pass_field = find_first(password_locators)

        if user_field is None or pass_field is None:
            raise RuntimeError("Username/password field not found on login page")

        try:
            user_field.fill(username)
            result["filled_username"] = True
        except Exception as e:
            logger.warning(f"Failed to fill username: {e}")

        try:
            pass_field.fill(password)
            result["filled_password"] = True
        except Exception as e:
            logger.warning(f"Failed to fill password: {e}")

        # Klik submit
        submit_locators = [
            'button[type="submit"]',
            'input[type="submit"]',
            'button:has-text("Login")',
            'button:has-text("Sign in")',
            'button:has-text("Masuk")'
        ]
        submit_btn = find_first(submit_locators)
        if submit_btn is None:
            # fallback: tekan Enter pada password field
            pass_field.press('Enter')
            result["clicked_submit"] = True
        else:
            submit_btn.click()
            result["clicked_submit"] = True

        # Tunggu settle setelah submit
        try:
            page.wait_for_load_state("networkidle", timeout=timeout_ms)
        except Exception:
            page.wait_for_timeout(1000)

        # Verifikasi sukses login bila ada indikator
        if success_indicator:
            # Coba sebagai selector CSS dulu
            try:
                if page.locator(success_indicator).count() > 0:
                    result["success"] = True
                else:
                    # Fallback: cek teks pada halaman
                    content = page.content()
                    result["success"] = success_indicator in (content or "")
            except Exception:
                content = page.content()
                result["success"] = success_indicator in (content or "")
        else:
            # Tanpa indikator spesifik, anggap sukses jika tidak ada error umum di halaman
            error_candidates = ['.error', '.alert-danger', '.invalid-feedback']
            has_errors = any(page.locator(sel).count() > 0 for sel in error_candidates)
            result["success"] = not has_errors

    except Exception as e:
        result["error"] = str(e)
        logger.error(f"Login error: {e}")

    return result
