"""Form detection and automated testing heuristics."""

from playwright.sync_api import Page, Locator
from typing import Dict, Any, List, Optional
import logging
import os

logger = logging.getLogger(__name__)


def detect_forms(page: Page) -> List[Dict[str, Any]]:
    """
    Detect all forms on the page.
    
    Args:
        page: Playwright page object
        
    Returns:
        List of form information dictionaries
    """
    forms = []
    form_elements = page.locator('form')
    
    for i in range(form_elements.count()):
        form = form_elements.nth(i)
        
        form_info = {
            'index': i,
            'action': form.get_attribute('action') or '',
            'method': form.get_attribute('method') or 'GET',
            'inputs': []
        }
        
        # Find all inputs in this form
        inputs = form.locator('input, textarea, select')
        for j in range(inputs.count()):
            input_elem = inputs.nth(j)
            input_type = input_elem.get_attribute('type') or 'text'
            
            # Skip buttons and submits for now
            if input_type in ['submit', 'button', 'image', 'reset']:
                continue
            
            input_info = {
                'type': input_type,
                'name': input_elem.get_attribute('name') or '',
                'id': input_elem.get_attribute('id') or '',
                'required': input_elem.get_attribute('required') is not None,
                'placeholder': input_elem.get_attribute('placeholder') or ''
            }
            form_info['inputs'].append(input_info)
        
        forms.append(form_info)
    
    return forms


def generate_dummy_data(input_type: str, name: str = '', placeholder: str = '') -> str:
    """
    Generate dummy data based on input type and context.
    
    Args:
        input_type: HTML input type
        name: Input name attribute
        placeholder: Input placeholder text
        
    Returns:
        Dummy value string
    """
    name_lower = name.lower()
    placeholder_lower = placeholder.lower()
    
    # Email detection
    if input_type == 'email' or 'email' in name_lower or 'email' in placeholder_lower:
        return 'test@example.com'
    
    # Password detection
    if input_type == 'password' or 'password' in name_lower or 'pass' in name_lower:
        return 'Test123!@#'
    
    # Phone detection
    if input_type == 'tel' or 'phone' in name_lower or 'tel' in name_lower:
        return '+1234567890'
    
    # Number detection
    if input_type == 'number':
        return '42'
    
    # Date detection
    if input_type == 'date':
        return '2024-01-15'
    
    # Time detection
    if input_type == 'time':
        return '14:30'
    
    # URL detection
    if input_type == 'url' or 'url' in name_lower or 'website' in name_lower:
        return 'https://example.com'
    
    # Name detection
    if 'name' in name_lower or 'nama' in name_lower:
        if 'first' in name_lower or 'depan' in name_lower:
            return 'John'
        elif 'last' in name_lower or 'belakang' in name_lower:
            return 'Doe'
        else:
            return 'John Doe'
    
    # Address detection
    if 'address' in name_lower or 'alamat' in name_lower:
        return '123 Main Street, City, State 12345'
    
    # Textarea or message
    if input_type == 'textarea' or 'message' in name_lower or 'comment' in name_lower:
        return 'This is a test message generated by automated testing.'
    
    # Default text
    return 'Test Input'


def fill_form(
    page: Page,
    form_index: int = 0,
    submit: bool = False
) -> Dict[str, Any]:
    """
    Automatically fill a form with dummy data.
    
    Args:
        page: Playwright page object
        form_index: Index of form to fill (default: 0)
        submit: Whether to submit the form (default: False)
        
    Returns:
        Dictionary with fill results
    """
    result = {
        'form_index': form_index,
        'fields_filled': 0,
        'fields_failed': 0,
        'submitted': False,
        'errors': []
    }
    
    try:
        # Enhanced form detection with better debugging
        forms = page.locator('form')
        form_count = forms.count()
        logger.info(f"Found {form_count} forms on page")
        
        if form_count == 0:
            logger.warning("No forms found, trying alternative selectors...")
            
            # Try alternative form selectors
            alt_form_selectors = [
                'form',
                '[role="form"]',
                '.form',
                '#form',
                'div[class*="form"]',
                'section[class*="form"]'
            ]
            
            for selector in alt_form_selectors:
                alt_forms = page.locator(selector)
                count = alt_forms.count()
                if count > 0:
                    logger.info(f"Found {count} elements with selector '{selector}'")
                    forms = alt_forms
                    form_count = count
                    break
        
        if form_count == 0:
            result['errors'].append("No forms found on page")
            logger.error("No forms found with any selector")
            return result
        
        if form_count <= form_index:
            result['errors'].append(f"Form index {form_index} not found (only {form_count} forms available)")
            logger.error(f"Form index {form_index} not found (only {form_count} forms available)")
            return result
        
        form = forms.nth(form_index)
        logger.info(f"Using form {form_index} with {form_count} total forms available")
        
        # Fill text inputs - expanded selectors for modern frameworks
        text_input_selectors = [
            'input[type="text"]',
            'input[type="email"]', 
            'input[type="tel"]',
            'input[type="url"]',
            'input[type="search"]',
            'input:not([type])',
            'input[type="number"]',
            'input[type="date"]',
            'input[type="time"]',
            'input[type="datetime-local"]',
            'input[type="month"]',
            'input[type="week"]',
            'input[type="color"]',
            'input[type="range"]',
            'input[type="file"]',
            'input[type="checkbox"]',
            'input[type="radio"]',
            'input[type="hidden"]',
            'input',  # Catch all inputs
            'textarea',
            'select'
        ]
        
        # Try each selector individually for better debugging
        total_inputs = 0
        for selector in text_input_selectors:
            try:
                inputs = form.locator(selector)
                count = inputs.count()
                if count > 0:
                    logger.info(f"Found {count} elements with selector '{selector}'")
                    total_inputs += count
            except Exception as e:
                logger.debug(f"Error with selector '{selector}': {e}")
        
        logger.info(f"Total inputs found: {total_inputs}")
        
        # Use comprehensive selector with better debugging
        text_inputs = form.locator('input, textarea, select')
        logger.info(f"Found {text_inputs.count()} total inputs in form {form_index}")
        
        # Additional debugging - check if form is actually found
        if text_inputs.count() == 0:
            logger.warning(f"No inputs found in form {form_index}, trying alternative selectors...")
            
            # Try alternative selectors
            alt_selectors = [
                'input:not([type="hidden"])',
                'input[type="text"], input[type="email"], input[type="password"], input[type="number"], input[type="date"], input[type="time"]',
                'textarea',
                'select'
            ]
            
            for alt_selector in alt_selectors:
                alt_inputs = form.locator(alt_selector)
                count = alt_inputs.count()
                if count > 0:
                    logger.info(f"Found {count} inputs with alternative selector: {alt_selector}")
                    text_inputs = alt_inputs
                    break
        
        for i in range(text_inputs.count()):
            try:
                input_elem = text_inputs.nth(i)
                name = input_elem.get_attribute('name') or ''
                input_type = input_elem.get_attribute('type') or 'text'
                placeholder = input_elem.get_attribute('placeholder') or ''
                
                # Get tag name safely
                try:
                    tag_name = input_elem.evaluate('el => el.tagName').lower()
                except Exception:
                    tag_name = 'unknown'
                
                logger.info(f"Processing input {i}: tag={tag_name}, type={input_type}, name={name}")
                
                # Skip hidden inputs
                if input_type == 'hidden':
                    logger.debug(f"Skipping hidden input: {name}")
                    continue
                
                # Check if input is visible and enabled with better error handling
                try:
                    is_visible = input_elem.is_visible()
                    is_disabled = input_elem.is_disabled()
                    logger.info(f"Input {i}: visible={is_visible}, disabled={is_disabled}")
                    
                    if not is_visible:
                        logger.info(f"Skipping invisible input: {name}")
                        continue
                        
                    if is_disabled:
                        logger.info(f"Skipping disabled input: {name}")
                        continue
                        
                except Exception as e:
                    logger.warning(f"Could not check visibility/disabled for input {i}: {e}")
                    # Continue anyway, might be a framework issue
                    logger.info(f"Attempting to fill input {i} anyway...")
                
                # Handle different input types
                if tag_name == 'select':
                    # Handle select elements
                    options = input_elem.locator('option')
                    if options.count() > 1:
                        input_elem.select_option(index=1)
                        result['fields_filled'] += 1
                        logger.info(f"Selected option in select '{name}'")
                elif input_type in ['checkbox', 'radio']:
                    # Handle checkboxes and radio buttons
                    if not input_elem.is_checked():
                        input_elem.check()
                        result['fields_filled'] += 1
                        logger.info(f"Checked {input_type} '{name}'")
                elif input_type == 'file':
                    # Skip file inputs for now
                    logger.debug(f"Skipping file input: {name}")
                    continue
                else:
                    # Handle text inputs
                    value = generate_dummy_data(input_type, name, placeholder)
                    input_elem.fill(value)
                    result['fields_filled'] += 1
                    logger.info(f"Filled input '{name}' (type: {input_type}) with '{value}'")
                    
            except Exception as e:
                result['fields_failed'] += 1
                result['errors'].append(f"Failed to fill input {i}: {str(e)}")
                logger.error(f"Failed to fill input {i}: {e}")
        
        # All input types are now handled in the main loop above
        
        # Submit if requested
        if submit:
            try:
                # Look for submit button with more selectors
                submit_selectors = [
                    'button[type="submit"]',
                    'input[type="submit"]',
                    'button:has-text("Submit")',
                    'button:has-text("Submit order")',
                    'button:has-text("Send")',
                    'button:has-text("Post")',
                    'button:has-text("Save")',
                    'button:has-text("Send Message")',
                    'button:has-text("Submit Form")',
                    'button:not([type])',  # Button without type (defaults to submit)
                    'input[type="button"]:has-text("Submit")',
                    'button'  # Any button in form (fallback)
                ]
                
                submit_button = None
                for selector in submit_selectors:
                    try:
                        btn = form.locator(selector).first
                        if btn.count() > 0 and btn.is_visible() and not btn.is_disabled():
                            submit_button = btn
                            logger.info(f"Found submit button with selector: {selector}")
                            break
                    except Exception:
                        continue
                
                if submit_button:
                    submit_button.click()
                    result['submitted'] = True
                    logger.info("Form submitted via submit button")
                    page.wait_for_timeout(1000)  # Wait for submission
                else:
                    # Try to submit via form
                    form.evaluate('form => form.submit()')
                    result['submitted'] = True
                    logger.info("Form submitted via form.submit()")
            except Exception as e:
                result['errors'].append(f"Failed to submit form: {str(e)}")
                logger.error(f"Failed to submit form: {e}")
        
        logger.info(f"Form filling completed: {result['fields_filled']} filled, {result['fields_failed']} failed")
        
        # If no fields were filled, try a more aggressive approach
        if result['fields_filled'] == 0:
            logger.warning("No fields were filled with standard approach, trying aggressive detection...")
            
            # Try to find any input on the page, not just in form
            page_inputs = page.locator('input:not([type="hidden"]), textarea, select')
            logger.info(f"Found {page_inputs.count()} inputs on entire page")
            
            # Also try to find form-like containers
            form_containers = page.locator('div[class*="form"], section[class*="form"], div[class*="field"], div[class*="input"]')
            logger.info(f"Found {form_containers.count()} form-like containers")
            
            for i in range(min(page_inputs.count(), 20)):  # Increased limit
                try:
                    input_elem = page_inputs.nth(i)
                    name = input_elem.get_attribute('name') or f'input_{i}'
                    input_type = input_elem.get_attribute('type') or 'text'
                    placeholder = input_elem.get_attribute('placeholder') or ''
                    
                    # Check if it's visible and not disabled
                    if input_elem.is_visible() and not input_elem.is_disabled():
                        try:
                            if input_type in ['checkbox', 'radio']:
                                if not input_elem.is_checked():
                                    input_elem.check()
                                    result['fields_filled'] += 1
                                    logger.info(f"Aggressively filled {input_type} '{name}'")
                            elif input_type == 'file':
                                # Skip file inputs for now
                                logger.debug(f"Skipping file input: {name}")
                                continue
                            else:
                                value = generate_dummy_data(input_type, name, placeholder)
                                input_elem.fill(value)
                                result['fields_filled'] += 1
                                logger.info(f"Aggressively filled input '{name}' with '{value}'")
                        except Exception as e:
                            logger.debug(f"Could not fill input {i} aggressively: {e}")
                except Exception as e:
                    logger.debug(f"Error in aggressive filling for input {i}: {e}")
            
            logger.info(f"Aggressive filling completed: {result['fields_filled']} filled")
    
    except Exception as e:
        result['errors'].append(f"Form filling error: {str(e)}")
        logger.error(f"Form filling error: {e}")
    
    return result


def save_session_state(page: Page) -> Dict[str, Any]:
    """
    Simpan state session untuk persistence.
    
    Args:
        page: Playwright page object
        
    Returns:
        Dictionary berisi session state
    """
    try:
        session_state = {
            'cookies': page.context.cookies(),
            'local_storage': page.evaluate('() => Object.fromEntries(Object.entries(localStorage))'),
            'session_storage': page.evaluate('() => Object.fromEntries(Object.entries(sessionStorage))'),
            'url': page.url
        }
        logger.info(f"Session state saved: {len(session_state['cookies'])} cookies")
        return session_state
    except Exception as e:
        logger.warning(f"Failed to save session state: {e}")
        return {}


def restore_session_state(page: Page, session_state: Dict[str, Any]) -> bool:
    """
    Pulihkan state session dari yang tersimpan.
    
    Args:
        page: Playwright page object
        session_state: Dictionary berisi session state
        
    Returns:
        True jika berhasil, False jika gagal
    """
    try:
        if 'cookies' in session_state:
            page.context.add_cookies(session_state['cookies'])
            logger.info(f"Session cookies restored: {len(session_state['cookies'])} cookies")
        
        if 'local_storage' in session_state:
            for key, value in session_state['local_storage'].items():
                page.evaluate(f'localStorage.setItem("{key}", "{value}")')
            logger.info(f"Local storage restored: {len(session_state['local_storage'])} items")
        
        if 'session_storage' in session_state:
            for key, value in session_state['session_storage'].items():
                page.evaluate(f'sessionStorage.setItem("{key}", "{value}")')
            logger.info(f"Session storage restored: {len(session_state['session_storage'])} items")
        
        return True
    except Exception as e:
        logger.warning(f"Failed to restore session state: {e}")
        return False


def check_session_validity(page: Page) -> bool:
    """
    Periksa apakah session masih valid dengan mengecek indikator login.
    
    Args:
        page: Playwright page object
        
    Returns:
        True jika session masih valid, False jika perlu login ulang
    """
    try:
        current_url = page.url.lower()
        
        # Cek URL untuk indikator login
        login_url_indicators = [
            '/login', '/signin', '/auth', '/masuk', '/admin/login',
            'login', 'signin', 'authentication'
        ]
        
        if any(indicator in current_url for indicator in login_url_indicators):
            logger.warning(f"Session invalid - current URL indicates login page: {current_url}")
            return False
        
        # Cek apakah ada indikator yang menunjukkan user sudah login
        login_indicators = [
            'a[href*="logout"]',
            'button:has-text("Logout")',
            'a:has-text("Logout")',
            '.user-menu',
            '.profile-menu',
            '[class*="user"]',
            '[class*="profile"]',
            '.admin-menu',
            '.dashboard-menu'
        ]
        
        for indicator in login_indicators:
            if page.locator(indicator).count() > 0:
                logger.info(f"Session valid - found login indicator: {indicator}")
                return True
        
        # Cek apakah ada indikator yang menunjukkan user belum login
        logout_indicators = [
            'a[href*="login"]',
            'button:has-text("Login")',
            'a:has-text("Login")',
            'input[type="password"]',
            'form[action*="login"]',
            'input[name*="password"]',
            'input[id*="password"]'
        ]
        
        for indicator in logout_indicators:
            if page.locator(indicator).count() > 0:
                logger.warning(f"Session invalid - found logout indicator: {indicator}")
                return False
        
        # Cek cookies untuk session
        try:
            cookies = page.context.cookies()
            session_cookies = [c for c in cookies if 'session' in c.get('name', '').lower() or 'auth' in c.get('name', '').lower()]
            if session_cookies:
                logger.info(f"Session valid - found {len(session_cookies)} session cookies")
                return True
        except Exception as e:
            logger.debug(f"Could not check cookies: {e}")
        
        # Jika tidak ada indikator yang jelas, anggap session valid
        logger.info("Session status unclear - assuming valid")
        return True
        
    except Exception as e:
        logger.warning(f"Failed to check session validity: {e}")
        return True  # Default to valid if check fails


def check_session_timeout(page: Page) -> Dict[str, Any]:
    """
    Periksa session timeout dengan berbagai metode deteksi.
    
    Args:
        page: Playwright page object
        
    Returns:
        Dictionary berisi informasi session timeout
    """
    result = {
        'has_timeout': False,
        'timeout_minutes': None,
        'timeout_source': None,
        'warnings': []
    }
    
    try:
        # Cek session timeout dari localStorage dan sessionStorage
        timeout_data = page.evaluate("""
            () => {
                const sources = [
                    { key: 'sessionTimeout', storage: localStorage },
                    { key: 'sessionTimeout', storage: sessionStorage },
                    { key: 'authTimeout', storage: localStorage },
                    { key: 'authTimeout', storage: sessionStorage },
                    { key: 'sessionExpiry', storage: localStorage },
                    { key: 'sessionExpiry', storage: sessionStorage },
                    { key: 'loginTimeout', storage: localStorage },
                    { key: 'loginTimeout', storage: sessionStorage }
                ];
                
                for (let source of sources) {
                    const value = source.storage.getItem(source.key);
                    if (value) {
                        const timeout = parseInt(value);
                        if (!isNaN(timeout) && timeout > 0) {
                            return {
                                timeout: timeout,
                                source: source.key,
                                storage: source.storage === localStorage ? 'localStorage' : 'sessionStorage'
                            };
                        }
                    }
                }
                return null;
            }
        """)
        
        if timeout_data:
            result['has_timeout'] = True
            result['timeout_minutes'] = timeout_data['timeout']
            result['timeout_source'] = f"{timeout_data['storage']}.{timeout_data['source']}"
            
            # Warning jika session timeout terlalu pendek
            if timeout_data['timeout'] < 30:
                result['warnings'].append(f"Session timeout is very short: {timeout_data['timeout']} minutes")
                logger.warning(f"Session timeout is very short: {timeout_data['timeout']} minutes")
        
        # Cek apakah ada indikator session expired di halaman
        expired_indicators = page.evaluate("""
            () => {
                const indicators = [
                    'session expired', 'session timeout', 'session invalid',
                    'login expired', 'authentication expired', 'token expired',
                    'sesi berakhir', 'sesi expired', 'waktu habis',
                    'session timeout', 'login timeout', 'auth timeout'
                ];
                
                const pageText = document.body.innerText.toLowerCase();
                for (let indicator of indicators) {
                    if (pageText.includes(indicator)) {
                        return indicator;
                    }
                }
                return null;
            }
        """)
        
        if expired_indicators:
            result['has_timeout'] = True
            result['timeout_source'] = f"page_content: {expired_indicators}"
            result['warnings'].append(f"Session expired indicator found in page: {expired_indicators}")
            logger.warning(f"Session expired indicator found: {expired_indicators}")
        
        # Cek cookies untuk session expiry
        try:
            cookies = page.context.cookies()
            for cookie in cookies:
                if 'expires' in cookie and cookie['expires']:
                    # Cek apakah cookie sudah expired
                    import datetime
                    if isinstance(cookie['expires'], (int, float)):
                        expiry_time = datetime.datetime.fromtimestamp(cookie['expires'])
                        if expiry_time < datetime.datetime.now():
                            result['has_timeout'] = True
                            result['warnings'].append(f"Session cookie expired: {cookie['name']}")
                            logger.warning(f"Session cookie expired: {cookie['name']}")
        except Exception as e:
            logger.debug(f"Could not check cookie expiry: {e}")
        
    except Exception as e:
        logger.warning(f"Failed to check session timeout: {e}")
    
    return result


def detect_login_redirect_cause(page: Page) -> Dict[str, Any]:
    """
    Deteksi penyebab redirect ke login page dengan analisis yang lebih mendalam.
    
    Args:
        page: Playwright page object
        
    Returns:
        Dictionary berisi analisis penyebab redirect
    """
    result = {
        'redirect_cause': 'Unknown',
        'error_messages': [],
        'session_indicators': [],
        'timeout_indicators': [],
        'auth_indicators': [],
        'recommendations': []
    }
    
    try:
        current_url = page.url.lower()
        page_content = page.content().lower()
        
        # Cek error messages yang spesifik
        error_selectors = [
            '.error', '.alert-danger', '.invalid-feedback', '.is-invalid',
            '[role="alert"]', '.error-message', '.field-error', '.validation-error',
            '.form-error', '.input-error', '.session-error', '.auth-error',
            '.login-error', '.timeout-error', '.expired-error'
        ]
        
        for selector in error_selectors:
            elements = page.locator(selector)
            if elements.count() > 0:
                for i in range(min(elements.count(), 5)):
                    error_text = elements.nth(i).text_content()
                    if error_text and error_text.strip():
                        result['error_messages'].append({
                            'selector': selector,
                            'text': error_text.strip()
                        })
        
        # Cek indikator session timeout
        timeout_indicators = [
            'session expired', 'session timeout', 'session invalid',
            'login expired', 'authentication expired', 'token expired',
            'sesi berakhir', 'sesi expired', 'waktu habis'
        ]
        
        for indicator in timeout_indicators:
            if indicator in page_content:
                result['timeout_indicators'].append(indicator)
                result['redirect_cause'] = f"Session timeout: {indicator}"
                result['recommendations'].append("Check session timeout configuration")
                result['recommendations'].append("Implement session timeout warnings")
                break
        
        # Cek indikator authentication error
        if result['redirect_cause'] == 'Unknown':
            auth_indicators = [
                'authentication required', 'login required', 'unauthorized',
                'access denied', 'permission denied', 'not authenticated',
                'harus login', 'perlu login', 'akses ditolak'
            ]
            
            for indicator in auth_indicators:
                if indicator in page_content:
                    result['auth_indicators'].append(indicator)
                    result['redirect_cause'] = f"Authentication error: {indicator}"
                    result['recommendations'].append("Check authentication status")
                    result['recommendations'].append("Verify user permissions")
                    break
        
        # Cek URL untuk indikator spesifik
        if result['redirect_cause'] == 'Unknown':
            if 'timeout' in current_url:
                result['redirect_cause'] = "Session timeout detected in URL"
                result['recommendations'].append("Check session timeout configuration")
            elif 'expired' in current_url:
                result['redirect_cause'] = "Session expired detected in URL"
                result['recommendations'].append("Implement session renewal")
            elif 'unauthorized' in current_url:
                result['redirect_cause'] = "Unauthorized access detected in URL"
                result['recommendations'].append("Check user permissions")
            elif 'login' in current_url:
                result['redirect_cause'] = "Redirect to login page - no specific error message found"
                result['recommendations'].append("Check session management")
                result['recommendations'].append("Implement session validation")
        
        # Cek session cookies
        try:
            cookies = page.context.cookies()
            session_cookies = [c for c in cookies if 'session' in c.get('name', '').lower() or 'auth' in c.get('name', '').lower()]
            if not session_cookies:
                result['session_indicators'].append("No session cookies found")
                result['recommendations'].append("Check session cookie configuration")
        except Exception as e:
            logger.debug(f"Could not check session cookies: {e}")
        
    except Exception as e:
        logger.warning(f"Failed to detect login redirect cause: {e}")
        result['redirect_cause'] = f"Error during analysis: {str(e)}"
    
    return result


def test_form_submission(
    page: Page,
    form_index: int = 0,
    timeout_ms: int = 5000,
    out_dir: str = None,
    safe_mode: bool = True
) -> Dict[str, Any]:
    """
    Test form submission dengan validasi yang lebih komprehensif.
    
    Args:
        page: Playwright page object
        form_index: Index of form to test
        timeout_ms: Timeout untuk menunggu response
        out_dir: Directory untuk menyimpan screenshot (optional)
        safe_mode: Jika True, hanya test form filling tanpa submit untuk menghindari session loss
        
    Returns:
        Test result dictionary dengan detail yang lebih lengkap
    """
    result = {
        'success': False,
        'fill_result': None,
        'response_status': None,
        'has_error_message': False,
        'has_success_message': False,
        'redirected': False,
        'url_changed': False,
        'form_validation_errors': [],
        'network_errors': [],
        'errors': [],
        'screenshot_before_path': None,
        'screenshot_after_path': None
    }
    
    try:
        # Simpan session state sebelum form testing
        session_state = save_session_state(page)
        result['session_state_saved'] = bool(session_state)
        
        # Cek session timeout dengan fungsi yang lebih komprehensif
        session_timeout_info = check_session_timeout(page)
        result['session_timeout_info'] = session_timeout_info
        
        if session_timeout_info['has_timeout']:
            logger.info(f"Session timeout detected: {session_timeout_info['timeout_minutes']} minutes from {session_timeout_info['timeout_source']}")
            result['session_timeout'] = session_timeout_info['timeout_minutes']
            
            # Warning jika session timeout terlalu pendek
            if session_timeout_info['timeout_minutes'] and session_timeout_info['timeout_minutes'] < 30:
                logger.warning(f"Session timeout is very short: {session_timeout_info['timeout_minutes']} minutes - may cause session loss")
                result['warnings'] = result.get('warnings', [])
                result['warnings'].append(f"Session timeout is very short: {session_timeout_info['timeout_minutes']} minutes")
        
        # Periksa session validity sebelum form testing
        session_valid = check_session_validity(page)
        if not session_valid:
            logger.warning("Session invalid - form submission may cause login redirect")
            result['errors'].append("Session invalid - form submission may cause login redirect")
            result['success'] = False
            return result
        
        # Ambil screenshot sebelum test dan simpan ke file jika out_dir tersedia
        if out_dir:
            try:
                before_path = os.path.join(out_dir, "form_before.png")
                page.screenshot(path=before_path, full_page=True)
                result['screenshot_before_path'] = before_path
            except Exception:
                pass
        
        # Fill the form first
        fill_result = fill_form(page, form_index, submit=False)
        result['fill_result'] = fill_result
        result['submitted'] = fill_result.get('submitted', False)
        
        if fill_result['fields_filled'] == 0:
            result['errors'].append("No fields were filled")
            return result
        
        # Check if we're in safe mode to avoid session loss
        if safe_mode:
            logger.info("🛡️ SAFE MODE ACTIVE - Form filling only, no submission")
            
            # Additional session validation in safe mode
            session_timeout_info = result.get('session_timeout_info', {})
            if session_timeout_info.get('has_timeout') and session_timeout_info.get('timeout_minutes', 0) < 30:
                logger.warning("🛡️ SAFE MODE: Session timeout is very short, form submission would likely cause session loss")
                result['safe_mode_reason'] = f"Session timeout too short: {session_timeout_info['timeout_minutes']} minutes"
            
            # Check for potential session issues
            session_valid = check_session_validity(page)
            if not session_valid:
                logger.warning("🛡️ SAFE MODE: Session already invalid, form submission would cause login redirect")
                result['safe_mode_reason'] = "Session already invalid"
            
            # Take screenshot after form filling (before submission)
            if out_dir:
                try:
                    after_path = os.path.join(out_dir, "form_after.png")
                    page.screenshot(path=after_path, full_page=True)
                    result['screenshot_after_path'] = after_path
                    logger.info(f"Screenshot saved to: {after_path}")
                except Exception as e:
                    logger.warning(f"Failed to take screenshot after form filling: {e}")
            
            result['success'] = True
            result['submitted'] = False
            result['safe_mode'] = True
            result['message'] = "Form filled successfully in safe mode (submission skipped to preserve session)"
            logger.info("🛡️ SAFE MODE: Returning result without form submission")
            return result
        
        # AUTO-SAFE MODE: Additional validation even when safe_mode=False
        # This provides automatic protection against session loss
        auto_safe_triggered = False
        auto_safe_reason = ""
        
        # Check session timeout - trigger auto-safe only for very short timeouts (< 5 minutes)
        session_timeout_info = result.get('session_timeout_info', {})
        if session_timeout_info.get('has_timeout') and session_timeout_info.get('timeout_minutes', 0) < 5:
            logger.warning("🛡️ AUTO-SAFE MODE: Critical session timeout, form submission will likely cause session loss")
            auto_safe_triggered = True
            auto_safe_reason = f"Critical session timeout: {session_timeout_info['timeout_minutes']} minutes"
        
        # Only check for critical session issues - be more lenient
        # Check if we're already on a login page (most critical case)
        if not auto_safe_triggered:
            current_url = page.url.lower()
            login_indicators = ['/login', '/signin', '/auth', '/masuk', '/admin/login']
            is_on_login_page = any(indicator in current_url for indicator in login_indicators)
            
            if is_on_login_page:
                logger.warning("🛡️ AUTO-SAFE MODE: Already on login page, form submission would be redundant")
                auto_safe_triggered = True
                auto_safe_reason = "Already on login page"
        
        # Check for missing session cookies - trigger auto-safe if no session cookies
        if not auto_safe_triggered:
            try:
                cookies = page.context.cookies()
                session_cookies = [c for c in cookies if 'session' in c.get('name', '').lower() or 'auth' in c.get('name', '').lower()]
                if not session_cookies:
                    logger.warning("⚠️ No session cookies found, form submission may cause login redirect")
                    result['warnings'] = result.get('warnings', [])
                    result['warnings'].append("No session cookies found - form submission may cause login redirect")
            except Exception as e:
                logger.debug(f"Could not check session cookies: {e}")
        
        # Check for missing session data - trigger auto-safe if no session data
        if not auto_safe_triggered:
            try:
                session_data = page.evaluate("""
                    () => {
                        const sessionKeys = ['session', 'auth', 'token', 'user', 'login'];
                        const found = [];
                        for (let key of sessionKeys) {
                            if (localStorage.getItem(key) || sessionStorage.getItem(key)) {
                                found.push(key);
                            }
                        }
                        return found;
                    }
                """)
                
                if not session_data:
                    logger.warning("⚠️ No session data found, form submission may cause login redirect")
                    result['warnings'] = result.get('warnings', [])
                    result['warnings'].append("No session data found - form submission may cause login redirect")
            except Exception as e:
                logger.debug(f"Could not check session data: {e}")
        
        # Only warn about form authentication requirements, don't trigger auto-safe
        if not auto_safe_triggered:
            try:
                form_requires_auth = page.evaluate("""
                    () => {
                        const forms = document.querySelectorAll('form');
                        const authIndicators = [
                            '/admin/', '/dashboard/', '/profile/', '/account/', '/user/',
                            '/api/', '/secure/', '/private/', '/protected/'
                        ];
                        
                        for (let form of forms) {
                            const action = form.action || '';
                            
                            // Cek action URL untuk indikator authentication
                            for (let indicator of authIndicators) {
                                if (action.includes(indicator)) {
                                    return {
                                        requires_auth: true,
                                        action: action,
                                        reason: 'Form action suggests authentication required'
                                    };
                                }
                            }
                            
                            // Cek apakah ada input hidden yang menunjukkan authentication
                            const hiddenInputs = form.querySelectorAll('input[type="hidden"]');
                            for (let input of hiddenInputs) {
                                const name = input.name.toLowerCase();
                                if (name.includes('auth') || name.includes('token') || name.includes('session')) {
                                    return {
                                        requires_auth: true,
                                        action: action,
                                        reason: 'Form contains authentication-related hidden inputs'
                                    };
                                }
                            }
                        }
                        
                        return { requires_auth: false };
                    }
                """)
                
                if form_requires_auth.get('requires_auth'):
                    logger.warning(f"⚠️ Form requires authentication: {form_requires_auth['reason']}")
                    result['form_requires_auth'] = form_requires_auth
                    result['warnings'] = result.get('warnings', [])
                    result['warnings'].append(f"Form requires authentication: {form_requires_auth['reason']}")
            except Exception as e:
                logger.debug(f"Could not check form authentication requirements: {e}")
        
        # If auto-safe mode is triggered, switch to safe mode
        if auto_safe_triggered:
            logger.info(f"🛡️ AUTO-SAFE MODE TRIGGERED: {auto_safe_reason}")
            
            # Take screenshot after form filling (before submission)
            if out_dir:
                try:
                    after_path = os.path.join(out_dir, "form_after.png")
                    page.screenshot(path=after_path, full_page=True)
                    result['screenshot_after_path'] = after_path
                    logger.info(f"Screenshot saved to: {after_path}")
                except Exception as e:
                    logger.warning(f"Failed to take screenshot after form filling: {e}")
            
            result['success'] = True
            result['submitted'] = False
            result['safe_mode'] = True
            result['auto_safe_mode'] = True
            result['safe_mode_reason'] = auto_safe_reason
            result['message'] = f"Form filled successfully in auto-safe mode (submission skipped to preserve session: {auto_safe_reason})"
            logger.info("🛡️ AUTO-SAFE MODE: Returning result without form submission")
            return result
        
        # Double check session validity before form submission (even in non-safe mode)
        session_still_valid = check_session_validity(page)
        if not session_still_valid:
            logger.warning("Session became invalid before form submission - switching to safe mode")
            result['success'] = True
            result['submitted'] = False
            result['safe_mode'] = True
            result['message'] = "Form filled successfully (submission skipped due to invalid session)"
            return result
        
        # Additional session validation - cek cookies dan localStorage
        try:
            # Cek apakah ada session cookies yang valid
            cookies = page.context.cookies()
            session_cookies = [c for c in cookies if 'session' in c.get('name', '').lower() or 'auth' in c.get('name', '').lower()]
            
            if not session_cookies:
                logger.warning("No session cookies found - form submission may cause login redirect")
                result['warnings'] = result.get('warnings', [])
                result['warnings'].append("No session cookies found - form submission may cause login redirect")
            
            # Cek localStorage untuk session data
            session_data = page.evaluate("""
                () => {
                    const sessionKeys = ['session', 'auth', 'token', 'user', 'login'];
                    const found = [];
                    for (let key of sessionKeys) {
                        if (localStorage.getItem(key) || sessionStorage.getItem(key)) {
                            found.push(key);
                        }
                    }
                    return found;
                }
            """)
            
            if not session_data:
                logger.warning("No session data found in localStorage/sessionStorage - form submission may cause login redirect")
                result['warnings'] = result.get('warnings', [])
                result['warnings'].append("No session data found - form submission may cause login redirect")
            
        except Exception as e:
            logger.debug(f"Could not check session data: {e}")
        
        # PROCEED WITH FORM SUBMISSION (when safe mode is disabled and no auto-safe triggers)
        logger.info("🚀 PROCEEDING WITH FORM SUBMISSION - Safe mode disabled and no auto-safe triggers")
        
        # Check for CSRF tokens and add them if needed
        csrf_tokens_found = 0
        try:
            # Look for existing CSRF tokens
            csrf_tokens = page.evaluate("""
                () => {
                    const csrfSelectors = [
                        'input[name*="csrf"]',
                        'input[name*="token"]',
                        'input[name*="_token"]',
                        'input[name*="authenticity_token"]',
                        'meta[name="csrf-token"]'
                    ];
                    
                    const found = [];
                    for (let selector of csrfSelectors) {
                        const elements = document.querySelectorAll(selector);
                        for (let el of elements) {
                            if (el.value && el.value.trim()) {
                                found.push({
                                    selector: selector,
                                    name: el.name || 'csrf_token',
                                    value: el.value.substring(0, 20) + '...'
                                });
                            }
                        }
                    }
                    return found;
                }
            """)
            
            if csrf_tokens:
                csrf_tokens_found = len(csrf_tokens)
                logger.info(f"CSRF tokens found: {csrf_tokens_found}")
                result['csrf_tokens_found'] = csrf_tokens_found
            else:
                logger.warning("No CSRF tokens found - form may require authentication")
                result['csrf_tokens_found'] = 0
                
                # Try to generate or find CSRF token
                try:
                    # Look for CSRF token in meta tags
                    csrf_meta = page.locator('meta[name="csrf-token"]')
                    if csrf_meta.count() > 0:
                        csrf_value = csrf_meta.get_attribute('content')
                        if csrf_value:
                            logger.info(f"Found CSRF token in meta tag: {csrf_value[:20]}...")
                            
                            # Add CSRF token to form if not present
                            forms = page.locator('form')
                            if forms.count() > 0:
                                form = forms.nth(form_index)
                                csrf_input = form.locator('input[name="_token"]')
                                if csrf_input.count() == 0:
                                    # Add CSRF token input to form
                                    page.evaluate(f"""
                                        () => {{
                                            const form = document.querySelectorAll('form')[{form_index}];
                                            if (form) {{
                                                const csrfInput = document.createElement('input');
                                                csrfInput.type = 'hidden';
                                                csrfInput.name = '_token';
                                                csrfInput.value = '{csrf_value}';
                                                form.appendChild(csrfInput);
                                            }}
                                        }}
                                    """)
                                    logger.info("Added CSRF token to form")
                                    csrf_tokens_found = 1
                                    result['csrf_tokens_found'] = 1
                                    result['csrf_token_added'] = True
                except Exception as e:
                    logger.debug(f"Could not add CSRF token: {e}")
        except Exception as e:
            logger.debug(f"Could not check CSRF tokens: {e}")
        
        # If form was already submitted in fill_form, we're done
        if fill_result.get('submitted'):
            logger.info("Form was already submitted in fill_form")
            result['submitted'] = True
        else:
            # Form was filled but not submitted, so we need to submit it
            logger.info("Form was filled but not submitted, attempting submission...")
            
            # PROCEED WITH ACTUAL FORM SUBMISSION
            logger.info("🚀 ATTEMPTING FORM SUBMISSION - All validations passed")
            
            # Simpan URL awal
            initial_url = page.url
            
            # Monitor network requests untuk error
            network_errors = []
            def handle_request_failed(request):
                network_errors.append({
                    'url': request.url,
                    'method': request.method,
                    'failure': str(request.failure)
                })
            
            page.on("requestfailed", handle_request_failed)
            
            # Submit form
            try:
                forms = page.locator('form')
                form_count = forms.count()
                logger.info(f"Found {form_count} forms for submission")
                
                if form_count == 0:
                    logger.warning("No forms found for submission, trying alternative selectors...")
                    
                    # Try alternative form selectors
                    alt_form_selectors = [
                        'form',
                        '[role="form"]',
                        '.form',
                        '#form',
                        'div[class*="form"]',
                        'section[class*="form"]'
                    ]
                    
                    for selector in alt_form_selectors:
                        alt_forms = page.locator(selector)
                        count = alt_forms.count()
                        if count > 0:
                            logger.info(f"Found {count} elements with selector '{selector}' for submission")
                            forms = alt_forms
                            form_count = count
                            break
                
                if form_count == 0:
                    result['errors'].append("No forms found for submission")
                    logger.error("No forms found for submission with any selector")
                    return result
                    
                if form_count <= form_index:
                    result['errors'].append(f"Form index {form_index} not found for submission (only {form_count} forms available)")
                    logger.error(f"Form index {form_index} not found for submission (only {form_count} forms available)")
                    return result
                    
                form = forms.nth(form_index)
                logger.info(f"Using form {form_index} for submission with {form_count} total forms available")
                
                # Try to find and click submit button
                submit_button = None
                submit_selectors = [
                    'button[type="submit"]',
                    'input[type="submit"]',
                    'button:has-text("Submit")',
                    'button:has-text("Submit order")',
                    'button:has-text("Send")',
                    'button:has-text("Post")',
                    'button:has-text("Save")',
                    'button:has-text("Send Message")',
                    'button:has-text("Submit Form")',
                    'button:not([type])',  # Button without type (defaults to submit)
                    'input[type="button"]:has-text("Submit")',
                    'button'  # Any button in form (fallback)
                ]
                
                for selector in submit_selectors:
                    try:
                        btn = form.locator(selector).first
                        if btn.count() > 0 and btn.is_visible() and not btn.is_disabled():
                            submit_button = btn
                            logger.info(f"Found submit button with selector: {selector}")
                            break
                    except Exception:
                        continue
                
                if submit_button:
                    # Submit form via button click
                    submit_button.click()
                    result['submitted'] = True
                    logger.info("Form submitted via submit button")
                else:
                    # Try to submit via form.submit()
                    form.evaluate('form => form.submit()')
                    result['submitted'] = True
                    logger.info("Form submitted via form.submit()")
                
                # Wait for response dengan timeout
                try:
                    page.wait_for_load_state("networkidle", timeout=timeout_ms)
                except Exception:
                    # Fallback jika networkidle timeout
                    page.wait_for_timeout(2000)
                    
            except Exception as e:
                result['errors'].append(f"Failed to submit form: {str(e)}")
                logger.error(f"Failed to submit form: {e}")
                return result
        
        # Simpan URL awal
        initial_url = page.url
        
        # Monitor network requests untuk error
        network_errors = []
        def handle_request_failed(request):
            network_errors.append({
                'url': request.url,
                'method': request.method,
                'failure': str(request.failure)
            })
        
        page.on("requestfailed", handle_request_failed)
        
        # Submit form only if not already submitted
        if not result.get('submitted', False):
            logger.info("Form not yet submitted, attempting submission...")
            
            # Final session check sebelum submission
            final_session_check = check_session_validity(page)
            if not final_session_check:
                logger.warning("Final session check failed - aborting form submission to prevent login redirect")
                result['success'] = True
                result['submitted'] = False
                result['safe_mode'] = True
                result['message'] = "Form submission aborted to prevent login redirect (session invalid)"
                return result
            
            try:
                forms = page.locator('form')
                form_count = forms.count()
                logger.info(f"Found {form_count} forms for final submission")
                
                if form_count == 0:
                    logger.warning("No forms found for final submission, trying alternative selectors...")
                    
                    # Try alternative form selectors
                    alt_form_selectors = [
                        'form',
                        '[role="form"]',
                        '.form',
                        '#form',
                        'div[class*="form"]',
                        'section[class*="form"]'
                    ]
                    
                    for selector in alt_form_selectors:
                        alt_forms = page.locator(selector)
                        count = alt_forms.count()
                        if count > 0:
                            logger.info(f"Found {count} elements with selector '{selector}' for final submission")
                            forms = alt_forms
                            form_count = count
                            break
                
                if form_count == 0:
                    result['errors'].append("No forms found for final submission")
                    logger.error("No forms found for final submission with any selector")
                    return result
                    
                if form_count <= form_index:
                    result['errors'].append(f"Form index {form_index} not found for final submission (only {form_count} forms available)")
                    logger.error(f"Form index {form_index} not found for final submission (only {form_count} forms available)")
                    return result
                    
                form = forms.nth(form_index)
                logger.info(f"Using form {form_index} for final submission with {form_count} total forms available")
                
                submit_button = form.locator('button[type="submit"], input[type="submit"]').first
                
                if submit_button.count() > 0:
                    # Submit form
                    submit_button.click()
                    result['submitted'] = True
                    logger.info("Form submitted via submit button in final submission")
                    
                    # Wait for response dengan timeout
                    try:
                        page.wait_for_load_state("networkidle", timeout=timeout_ms)
                    except Exception:
                        # Fallback jika networkidle timeout
                        page.wait_for_timeout(2000)
                else:
                    # Try to submit via form
                    form.evaluate('form => form.submit()')
                    result['submitted'] = True
                    logger.info("Form submitted via form.submit() in final submission")
                    
            except Exception as e:
                result['errors'].append(f"Failed to submit form in final submission: {str(e)}")
                logger.error(f"Failed to submit form in final submission: {e}")
                return result
        else:
            logger.info("Form already submitted, skipping final submission")
        
        # Simpan screenshot setelah submit ke file jika out_dir tersedia
        if out_dir:
            try:
                after_path = os.path.join(out_dir, "form_after.png")
                page.screenshot(path=after_path, full_page=True)
                result['screenshot_after_path'] = after_path
            except Exception:
                pass
        
        # Check URL change and detect login redirect
        result['url_changed'] = page.url != initial_url
        result['redirected'] = result['url_changed']
        
        # Check if redirected to login page
        current_url = page.url.lower()
        login_indicators = [
            '/login', '/signin', '/auth', '/masuk', '/admin/login',
            'login', 'signin', 'authentication'
        ]
        
        is_login_redirect = any(indicator in current_url for indicator in login_indicators)
        result['redirected_to_login'] = is_login_redirect
        
        # Double check session validity after form submission
        if not is_login_redirect:
            session_still_valid = check_session_validity(page)
            if not session_still_valid:
                logger.warning("Session became invalid after form submission")
                result['errors'].append("Session became invalid after form submission")
                result['success'] = False
                return result
        else:
            # Jika redirect ke login, gunakan fungsi deteksi yang lebih komprehensif
            logger.info("Analyzing login redirect causes...")
            redirect_analysis = detect_login_redirect_cause(page)
            result['redirect_analysis'] = redirect_analysis
            result['login_redirect_reason'] = redirect_analysis['redirect_cause']
            
            # Log hasil analisis
            logger.info(f"Login redirect cause: {redirect_analysis['redirect_cause']}")
            if redirect_analysis['error_messages']:
                logger.info(f"Error messages found: {len(redirect_analysis['error_messages'])}")
            if redirect_analysis['timeout_indicators']:
                logger.info(f"Timeout indicators: {redirect_analysis['timeout_indicators']}")
            if redirect_analysis['auth_indicators']:
                logger.info(f"Auth indicators: {redirect_analysis['auth_indicators']}")
            if redirect_analysis['recommendations']:
                logger.info(f"Recommendations: {redirect_analysis['recommendations']}")
        
        if is_login_redirect:
            logger.warning(f"Form submission redirected to login page: {page.url}")
            
            # Coba pulihkan session state jika tersimpan
            if session_state:
                logger.info("Attempting to restore session state...")
                restore_success = restore_session_state(page, session_state)
                if restore_success:
                    logger.info("Session state restored successfully")
                    result['session_restored'] = True
                    
                    # Coba navigasi kembali ke halaman asli
                    try:
                        page.goto(initial_url, wait_until="load", timeout=5000)
                        logger.info(f"Navigated back to original page: {initial_url}")
                        
                        # Verifikasi bahwa session sudah pulih
                        session_recovered = check_session_validity(page)
                        if session_recovered:
                            logger.info("Session recovery successful - user is back to authenticated state")
                            result['session_recovery_success'] = True
                        else:
                            logger.warning("Session recovery failed - still on login page")
                            result['session_recovery_success'] = False
                    except Exception as e:
                        logger.warning(f"Failed to navigate back to original page: {e}")
                        result['session_recovery_success'] = False
                else:
                    logger.warning("Failed to restore session state")
                    result['session_restored'] = False
                    result['session_recovery_success'] = False
            else:
                logger.warning("No session state available for recovery")
                result['session_restored'] = False
                result['session_recovery_success'] = False
            
            # Analisis penyebab redirect ke login sudah dilakukan di atas
            redirect_reason = result.get('login_redirect_reason', 'Unknown')
            logger.info(f"Login redirect reason: {redirect_reason}")
            
            # Tambahkan rekomendasi dari analisis
            if 'redirect_analysis' in result and result['redirect_analysis']['recommendations']:
                result['recommendations'] = result['redirect_analysis']['recommendations']
                logger.info(f"Recommendations: {result['redirect_analysis']['recommendations']}")
            
            result['errors'].append(f"Form submission caused redirect to login page - possible session loss. Reason: {redirect_reason}")
            result['success'] = False
            return result
        
        # Check for validation errors (lebih comprehensive)
        validation_error_selectors = [
            '.error', '.alert-danger', '.invalid-feedback', '.is-invalid',
            '[role="alert"]', '.error-message', '.field-error',
            '.validation-error', '.form-error', '.input-error',
            '[class*="error"]', '[class*="invalid"]'
        ]
        
        for selector in validation_error_selectors:
            elements = page.locator(selector)
            if elements.count() > 0:
                for i in range(min(elements.count(), 5)):  # Limit to 5 errors
                    error_text = elements.nth(i).text_content()
                    if error_text and error_text.strip():
                        result['form_validation_errors'].append({
                            'selector': selector,
                            'text': error_text.strip()[:200]  # Limit text length
                        })
                result['has_error_message'] = True
        
        # Check for success indicators (lebih comprehensive)
        success_selectors = [
            '.success', '.alert-success', '.success-message',
            '[role="status"]', '.form-success', '.submission-success',
            '.thank-you', '.confirmation', '[class*="success"]'
        ]
        
        for selector in success_selectors:
            elements = page.locator(selector)
            if elements.count() > 0:
                for i in range(min(elements.count(), 3)):  # Limit to 3 success messages
                    success_text = elements.nth(i).text_content()
                    if success_text and success_text.strip():
                        result['has_success_message'] = True
                        break
                if result['has_success_message']:
                    break
        
        # Check for common success indicators in text
        page_content = page.content()
        success_indicators = [
            'thank you', 'success', 'submitted', 'received',
            'confirmation', 'complete', 'done'
        ]
        
        if any(indicator in page_content.lower() for indicator in success_indicators):
            result['has_success_message'] = True
        
        # Simpan network errors
        result['network_errors'] = network_errors
        
        # Determine overall success
        if result['has_error_message'] or network_errors:
            result['success'] = False
        elif result['has_success_message'] or result['redirected']:
            result['success'] = True
        else:
            # Ambiguous case - check if form is still there (might indicate failure)
            remaining_forms = page.locator('form').count()
            if remaining_forms == 0:
                result['success'] = True  # Form disappeared, likely successful
            else:
                result['success'] = False  # Form still there, might have failed
    
    except Exception as e:
        result['errors'].append(f"Form test error: {str(e)}")
        logger.error(f"Form submission test failed: {e}")
    
    return result


def perform_login(
    page: Page,
    login_url: str,
    username: str,
    password: str,
    success_indicator: Optional[str] = None,
    timeout_ms: int = 10000
) -> Dict[str, Any]:
    """
    Lakukan proses login menggunakan heuristik umum.

    Args:
        page: Objek Playwright Page
        login_url: URL halaman login
        username: Nilai username/email
        password: Nilai password
        success_indicator: Selector CSS atau teks yang menandakan login berhasil
        timeout_ms: Timeout operasi dalam milidetik

    Returns:
        Hasil proses login berisi status dan rincian langkah.
    """
    result: Dict[str, Any] = {
        "navigated": False,
        "filled_username": False,
        "filled_password": False,
        "clicked_submit": False,
        "success": False,
        "error": None
    }

    try:
        # Buka halaman login
        page.goto(login_url, wait_until="load", timeout=timeout_ms)
        page.wait_for_timeout(500)
        result["navigated"] = True

        # Cari field username/email (prioritaskan selector eksplisit jika ada di dataset global)
        username_locators = [
            'input[type="email"]',
            'input[name*="email" i]',
            'input[id*="email" i]',
            'input[name*="user" i]',
            'input[id*="user" i]',
            'input[type="text"]'
        ]
        password_locators = [
            'input[type="password"]',
            'input[name*="pass" i]',
            'input[id*="pass" i]'
        ]

        def find_first(locators: List[str]) -> Optional[Locator]:
            for sel in locators:
                loc = page.locator(sel).first
                try:
                    if loc.count() > 0:
                        return loc
                except Exception:
                    continue
            return None

        user_field = find_first(username_locators)
        pass_field = find_first(password_locators)

        if user_field is None or pass_field is None:
            raise RuntimeError("Username/password field not found on login page")

        try:
            user_field.fill(username)
            result["filled_username"] = True
        except Exception as e:
            logger.warning(f"Failed to fill username: {e}")

        try:
            pass_field.fill(password)
            result["filled_password"] = True
        except Exception as e:
            logger.warning(f"Failed to fill password: {e}")

        # Klik submit
        submit_locators = [
            'button[type="submit"]',
            'input[type="submit"]',
            'button:has-text("Login")',
            'button:has-text("Sign in")',
            'button:has-text("Masuk")'
        ]
        submit_btn = find_first(submit_locators)
        if submit_btn is None:
            # fallback: tekan Enter pada password field
            pass_field.press('Enter')
            result["clicked_submit"] = True
        else:
            submit_btn.click()
            result["clicked_submit"] = True

        # Tunggu settle setelah submit
        try:
            page.wait_for_load_state("networkidle", timeout=timeout_ms)
        except Exception:
            page.wait_for_timeout(1000)
        
        # Simpan session/cookies untuk persistence
        try:
            # Simpan cookies ke context untuk session persistence
            cookies = page.context.cookies()
            logger.info(f"Session cookies saved: {len(cookies)} cookies")
            
            # Simpan session timeout information
            session_timeout = page.evaluate("""
                () => {
                    // Cek session timeout dari localStorage atau sessionStorage
                    const sessionTimeout = localStorage.getItem('sessionTimeout') || 
                                         sessionStorage.getItem('sessionTimeout') ||
                                         localStorage.getItem('authTimeout') ||
                                         sessionStorage.getItem('authTimeout');
                    return sessionTimeout ? parseInt(sessionTimeout) : null;
                }
            """)
            
            if session_timeout:
                logger.info(f"Session timeout detected: {session_timeout} minutes")
        except Exception as e:
            logger.warning(f"Failed to save session cookies: {e}")

        # Verifikasi sukses login bila ada indikator
        if success_indicator:
            # Coba sebagai selector CSS dulu
            try:
                if page.locator(success_indicator).count() > 0:
                    result["success"] = True
                else:
                    # Fallback: cek teks pada halaman
                    content = page.content()
                    result["success"] = success_indicator in (content or "")
            except Exception:
                content = page.content()
                result["success"] = success_indicator in (content or "")
        else:
            # Tanpa indikator spesifik, anggap sukses jika tidak ada error umum di halaman
            error_candidates = ['.error', '.alert-danger', '.invalid-feedback']
            has_errors = any(page.locator(sel).count() > 0 for sel in error_candidates)
            result["success"] = not has_errors

    except Exception as e:
        result["error"] = str(e)
        logger.error(f"Login error: {e}")

    return result
